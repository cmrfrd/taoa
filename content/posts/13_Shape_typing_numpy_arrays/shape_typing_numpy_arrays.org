#+TITLE: Preventing numpy shape errors with pyright and variadic generics
#+CREATED: <2023-02-27 Mon>
#+LAST_MODIFIED: [2023-03-06 Mon 03:01]
#+ROAM_TAGS: composition
#+OPTIONS: toc:nil
#+OPTIONS: tex:t
#+OPTIONS: _:nil ^:nil p:nil

#+HUGO_BASE_DIR: ./
#+hugo_front_matter_format: yaml
#+HUGO_CUSTOM_FRONT_MATTER: :date (org-to-blog-date (org-global-prop-value "CREATED"))
#+HUGO_CUSTOM_FRONT_MATTER: :hero ./images/cover.jpg
#+HUGO_CUSTOM_FRONT_MATTER: :secret false
#+HUGO_CUSTOM_FRONT_MATTER: :excerpt MxN * NxM

#+BEGIN_SRC emacs-lisp :exports none
  (defun org-hugo-link (link contents info) (org-md-link link contents info))

  ;; Setup org/latex exporting
  (add-to-list 'org-export-filter-latex-fragment-functions
               'sub-paren-for-dollar-sign)
  (add-to-list 'org-export-filter-headline-functions
               'remove-regexp-curly-braces)
  (add-to-list 'org-export-filter-latex-environment-functions
               'sub-paren-for-dollar-sign)
  (export-to-mdx-on-save)
#+END_SRC

#+RESULTS:
: Disabled mdx on save

When doing any sort of tensor/array computation in python (via ~numpy~, ~pytorch~, ~jax~, or
otherwise), it's more frequent than not we encounter shape errors like the one below

  #+CONSTANTS: image_name=pyright container_name=pyright
  #+CONSTANTS: image_name_shape_typing=cmrfrd/numpy_shape_typing-dev container_name_shape_typing=numpy_shape_typing-dev

  #+NAME: setup-vars
  #+HEADER: :exports none
  #+begin_src emacs-lisp
    (setq docker-tramp-docker-executable "podman")
    (docker-tramp-add-method)
    (setq org-babel-inline-result-wrap "$%s$")
    (setq shutdown-env nil)
    (setq ob-ipython-command "python")
    (setq org-babel-python-command "python")
    (setq py-default-interpreter "python")
  #+end_src

  #+RESULTS: setup-vars
  : python

  #+NAME: container-dir-str
  #+HEADER: :exports none
  #+begin_src emacs-lisp
    (setq container-dir-str (format "/docker:root@%s:/mnt" (org-table-get-constant "container_name")))
  #+end_src

  #+RESULTS: container-dir-str
  : /docker:root@pyright:/mnt

  #+NAME: container-dir-str-shape-typing
  #+HEADER: :exports none
  #+begin_src emacs-lisp
    (setq container-dir-str-shape-typing (format "/docker:user@%s:/mnt" (org-table-get-constant "container_name_shape_typing")))
  #+end_src

  #+RESULTS: container-dir-str-shape-typing
  : /docker:user@numpy_shape_typing-dev:/mnt

  #+NAME: container-dir-str-shape-typing-project
  #+HEADER: :exports none
  #+begin_src emacs-lisp
    (setq container-dir-str-shape-typing-project (format "/docker:user@%s:/opt/project" (org-table-get-constant "container_name_shape_typing")))
  #+end_src

  #+RESULTS: container-dir-str-shape-typing-project
  : /docker:user@numpy_shape_typing-dev:/opt/project

  #+NAME: init
  #+HEADER: :exports none :results output
  #+begin_src python :session numpy
    print("init")
  #+end_src

  #+RESULTS: init
  : init

  #+NAME: example-fail
  #+HEADER: :exports none :results output verbatim
  #+begin_src python :session numpy
    import numpy as np

    axes1 = (2,3)
    axes2 = (4,3)

    M1 = np.random.random(size=axes1)
    M2 = np.random.random(size=axes2)

    try:
        print(np.dot(M1,M2))
    except Exception as e:
        print(e)
  #+end_src

  #+RESULTS: example-fail
  : shapes (2,3) and (4,3) not aligned: 3 (dim 1) != 4 (dim 0)

  And most of the time, these kind of errors boil down to something like
  accidentally forgetting to do a reshape or transpose like so.

  #+NAME: example-success
  #+HEADER: :exports none :results output verbatim
  #+begin_src python :session numpy
    import numpy as np

    axes1 = (2,3)
    axes2 = (4,3)

    M1 = np.random.random(size=axes1)
    M2 = np.random.random(size=axes2).T

    try:
        print(np.dot(M1,M2))
    except Exception as e:
        print(e)
  #+end_src

  #+RESULTS: example-success
  : [[0.26210787 0.9858254  0.89502795 0.34813758]
  :  [0.37646863 0.3790563  0.35087926 0.14548013]]

  And while this is a mild case, shape bugs like these become more frequent as
  operations grow more complex and as more dimensions are involved.

  Here's a slightly more complex example of a ~Linear~ implementation in ~numpy~
  with a subtle shape bug.

  #+NAME: linear-bug
  #+HEADER: :exports none :results output verbatim
  #+begin_src python :session numpy
    def Linear(A, x, b):
        """
        Takes matrix A (m x n) times a vector x (n x 1) and
        adds a bias. The resulting ndarray is then ravelled
        into a vector of size (m).
        """
        Ax = np.dot(A, x)
        Axb = np.add(Ax, b)
        return np.ravel(Axb)

    A = np.random.random(size=(4,4))
    x = np.random.random(size=(4,1))
    b = np.random.random(size=(4))

    result = Linear(A, x, b)
    print(result)
    print(result.shape)
  #+end_src

  #+RESULTS: linear-bug
  : [1.37932258 1.48121007 1.7228994  1.73685425 1.19747849 1.29936598
  :  1.54105531 1.55501016 1.01962288 1.12151038 1.36319971 1.37715455
  :  0.69472436 0.79661186 1.03830119 1.05225603]
  : (16,)

  The docstring of ~Linear~ clearly says the result should be size ~m~ (or
  ~4~). But why then did we end up with a vector of size ~16~? If we dig into
  each function we will eventually find that our problem is in how ~numpy~
  handles ~ndarrays~ of differing shapes.

  If we break down ~Linear~, after ~np.dot~ we have an ~ndarray~ of shape
  ~(4,1)~ of which we do ~np.add~ with a vector of shape ~(4)~. And here lies
  our bug. We might naturally think that ~np.add~ will do this addition element
  wise, but instead we fell into an [[https://numpy.org/doc/stable/user/basics.broadcasting.html#broadcastable-arrays][array broadcasting]] trap. Array broadcasting
  are sets of rules ~numpy~ uses to determine how to do arithmetic on different
  shaped ~ndarrays~. So instead of doing our computation element wise, ~numpy~
  interprets this as doing a broadcast operation of addition, resulting in a
  ~(4,4)~ matrix, which subsequently gets "raveled" into a size ~16~ vector.

  Now to fix this is easy, we just need to initialize our ~b~ variable to be of
  shape ~(4,1)~ so ~numpy~ will interpret the ~np.add~ as an element wise
  addition.

  #+NAME: linear-bug-fixed
  #+HEADER: :exports none :results output verbatim
  #+begin_src python :session numpy
    def Linear(A, x, b):
        """
        Takes matrix A (m x n) times a vector x (n x 1) and
        adds a bias. The resulting ndarray is then ravelled
        into a vector of size (m).
        """
        Ax = np.dot(A, x)
        Axb = np.add(Ax, b)
        return np.ravel(Axb)

    A = np.random.random(size=(4,4))
    x = np.random.random(size=(4,1))
    b = np.random.random(size=(4,1))

    result = Linear(A, x, b)
    print(result)
    print(result.shape)
  #+end_src

  #+RESULTS: linear-bug-fixed
  : [1.61890606 1.02107972 1.54771397 1.44444939]
  : (4,)

  We've solved the problem, but how can we be smarter to prevent this error from
  happening again?

* Existing ways to stop shape bugs

  The simplest (yet crudest) way we can try to stop this shape bug is with good
  docs. Ideally we should always have good docs, but we can make it a point to
  include what the shape expectations are like so:

  #+NAME: linear-good-docs
  #+HEADER: :exports none :results output verbatim
  #+begin_src python :session numpy
    def Linear(A, x, b):
        """
        Args:
            A: ndarray of shape (M x N)
            x: ndarray of shape (N x 1)
            b: ndarray of shape (M x 1)

        Returns:
            Linear output ndarray of shape (M)
        """
        Ax = np.dot(A, x) # Shape (M x 1)
        Axb = np.add(Ax, b) # (M x 1) + (M x 1)
        return np.ravel(Axb) # Shape (M)
  #+end_src

  #+RESULTS: linear-good-docs

  Now while informative, nothing is preventing us from encountering the same bug
  again. The only benefit this gives us, is making the debugging process a
  bit easier.

  We can do better.

  Another approach in addition to good docs that's more of a preventative action
  is to use assertions. By sprinkling ~assert~ throughout ~Linear~ with an
  informative error message, we can "fail early" and start debugging like so:

  #+NAME: linear-asserts
  #+HEADER: :exports none :results output verbatim
  #+begin_src python :session numpy
    def Linear(A, x, b):
        """
        Args:
            A: ndarray of shape (M x N)
            x: ndarray of shape (N x 1)
            b: ndarray of shape (M x 1)

        Returns:
            Linear output ndarray of shape (M)
        """
        assert len(A.shape) == 2, f"A must be of dim 2, not {len(A.shape)}"
        Am, An = A.shape

        assert x.shape == (An, 1), f"X must be shape ({An}, 1) to do dot"
        Ax = np.dot(A, x) # Shape (M x 1)

        assert b.shape == (Am, 1), f"Bias term must be shape ({Am}, 1)"
        result = np.add(Ax, b) # (M x 1) + (M x 1)

        ravel_result = np.ravel(result)
        assert ravel_result.shape == (Am,), f"Uh oh, ravel result is shape {ravel_result.shape} and not {(Am,)}"
        return ravel_result
  #+end_src

  #+RESULTS: linear-asserts

  ~Linear~ is a bit "safer" now. But compared to what we had originally, this
  approach is much less readable. We also inherit some of the baggage that comes
  with runtime error checking we need to think about such as:

  - *Incomplete checking*: Have we checked all expected failure modes?

  - *Slow debugging cycles*: How many refactor->rerun cycles will we have to do
    pass the checks?

  - *Additional testing*: Do the tests cover our runtime error checks?

  Overall runtime error checking is not a bad thing and in most cases is
  necessary! But when it comes to shape errors we can try to leverage a third
  approach, static type checking.

* ~dtype~ typing ~numpy~ arrays

  As of writing this post, ~numpy==v1.24.2~ only supports typing on an
  ~ndarray~'s ~dtype~ (~uint8~, ~float64~, etc.).

  Using ~numpy~'s existing type tooling, here's how we would include ~dtype~
  type information to our ~Linear~ example (note: there is an intentional type
  error)

  #+NAME: linear-typing-dtype
  #+HEADER: :exports none :results output verbatim :tangle linear_bad_typing.py
  #+begin_src python :session numpy
    from typing import TypeVar

    import numpy as np
    from numpy.typing import NDArray

    GenericType = TypeVar("GenericType", bound=np.generic)


    def Linear(
            A: NDArray[GenericType],
            x: NDArray[GenericType],
            b: NDArray[GenericType],
    ) -> NDArray[GenericType]:
        """
        Args:
            A: ndarray of shape (M x N)
            x: ndarray of shape (N x 1)
            b: ndarray of shape (M x 1)

        Returns:

            Linear output ndarray of shape (M)
        """
        assert len(A.shape) == 2, f"A must be of dim 2, not {len(A.shape)}"
        Am, An = A.shape

        assert x.shape == (An, 1), f"X must be shape ({An}, 1) to do dot"
        Ax: NDArray[GenericType] = np.dot(A, x)  # Shape (M x 1)

        assert b.shape == (Am, 1), f"Bias term must be shape ({Am}, 1)"
        result: NDArray[GenericType] = np.add(Ax, b)  # (M x 1) + (M x 1)

        ravel_result: NDArray[GenericType] = np.ravel(result)
        assert ravel_result.shape == (Am,), f"Uh oh, ravel result is shape {ravel_result.shape} and not {(Am,)}"
        return ravel_result


    A: NDArray[np.float64] = np.random.standard_normal(size=(10, 10))
    x: NDArray[np.float64] = np.random.standard_normal(size=(10, 1))
    b: NDArray[np.float32] = np.random.standard_normal(size=(10, 1))
    y: NDArray[np.float64] = Linear(A, x, b)
    print(y)
  #+end_src

  #+RESULTS: linear-typing-dtype
  : [-2.71019241 -2.81848162  0.6833062  -0.33208219 -0.09177579  0.10964564
  :  -4.72878577  1.19790715 -3.78049511 -2.65254407]

  #+NAME: pyright-environment-build
  #+HEADER: :exports code :padline no
  #+BEGIN_SRC podman-build :dir "." :tangle (make-temp-name "Dockerfile-") :tag (org-table-get-constant "image_name")
    FROM python:3.11.2-slim
    USER root
    RUN pip install pyright numpy
    CMD ["sleep", "infinity"]
  #+END_SRC

  #+RESULTS: pyright-environment-build
  : #<window 76 on /tmp/babel-x2dUJT/ob-podman-build-out-2Wxdag>

  #+NAME: pyright-environment-start
  #+HEADER: :exports none
  #+begin_src bash :results verbatim :var NAME=(org-table-get-constant "container_name")
    echo "Running container if not already running ..."
    [ ! "$(podman ps | grep $NAME)" ] && \
      (podman run \
              -d \
              --name $NAME \
              --rm \
              -v $(pwd):/mnt \
              -w /mnt \
              -it pyright:latest; \
       echo "Container starting...") \
        || \
        echo "Container already running..."
  #+end_src

  #+RESULTS: pyright-environment-start
  : Running container if not already running ...
  : e2743f3a67bd5c137d9d718cc2a4eeeceeef47295c25b12d6c5a011ec89f551f
  : Container starting...

  Even though our code is "runnable", we can expand our view of what "correct"
  and "runnable" means by putting our code through a type checker. And when we
  do use a type checker like ~pyright~, it tells us a different story.

  #+NAME: pyright-bad-typing
  #+HEADER: :results output
  #+begin_src bash :dir (org-sbe container-dir-str) :session pyright
    pyright linear_bad_typing.py
  #+end_src

  #+RESULTS: pyright-bad-typing
  #+begin_example
  No configuration file found.
  No pyproject.toml file found.
  stubPath /mnt/typings is not a valid directory.
  Assuming Python platform Linux
  Searching for source files
  Found 1 source file
  pyright 1.1.296
  /mnt/linear_bad_typing.py
    /mnt/linear_bad_typing.py:40:26 - error: Expression of type "ndarray[Any, dtype[float64]]" cannot be assigned to declared type "NDArray[float32]"
      "ndarray[Any, dtype[float64]]" is incompatible with "NDArray[float32]"
        TypeVar "_DType_co@ndarray" is covariant
          "dtype[float64]" is incompatible with "dtype[float32]"
            TypeVar "_DTypeScalar_co@dtype" is covariant
              "float64" is incompatible with "float32" (reportGeneralTypeIssues)
    /mnt/linear_bad_typing.py:41:39 - error: Argument of type "NDArray[float32]" cannot be assigned to parameter "b" of type "NDArray[GenericType@Linear]" in function "Linear"
      "NDArray[float32]" is incompatible with "NDArray[float64]"
        TypeVar "_DType_co@ndarray" is covariant
          "dtype[float32]" is incompatible with "dtype[float64]"
            TypeVar "_DTypeScalar_co@dtype" is covariant
              "float32" is incompatible with "float64" (reportGeneralTypeIssues)
  2 errors, 0 warnings, 0 informations
  Completed in 0.611sec
  #+end_example

  ~pyright~ has noticed that when we create our ~b~ variable we gave it a
  ~dtype~ type that is incompatible with ~np.random.standard_normal~. Using this
  information we know we should adjust the type hint of ~b~ to be in line with
  what is expected of ~np.random.standard_normal~ (by changing the type of ~b~
  to ~NDArray[np.float64]~).

* Shape typing ~numpy~ arrays

  While ~dtype~ typing is great, it's not the most useful for preventing shape
  errors. Ideally it would be great if our code could include shape typing
  instead.

  Shape typing is a technique used to annotate shape information on your array
  variables. In the context of ~numpy~, shape typing can be used to enforce
  constraints on the dimensionality and size of arrays in order to catch shape
  errors before runtime.

  Compared to our original code, shape typing would give us the same ~assert~
  like information when shapes are invalid, but would take place in the type
  hinting system so a type checker can catch them before runtime.

  As we've seen however, ~numpy~'s ~NDArray~ doesn't have this kind of typing
  ability yet. But why is that? If we dig into the definition of the ~NDArray~
  type ...

  #+begin_src python
    ScalarType = TypeVar("ScalarType", bound=np.generic, covariant=True)

    if TYPE_CHECKING or sys.version_info >= (3, 9):
        _DType = np.dtype[ScalarType]
        NDArray = np.ndarray[Any, np.dtype[ScalarType]]
    else:
        _DType = _GenericAlias(np.dtype, (ScalarType,))
        NDArray = _GenericAlias(np.ndarray, (Any, _DType))
  #+end_src

  And follow the definition of ~np.ndarray~ ...

  #+begin_src python
    class ndarray(_ArrayOrScalarCommon, Generic[_ShapeType, _DType_co]):
  #+end_src

  We can see that it looks like ~numpy~ uses a ~Shape~ type already! But
  unfortunately if we look at the definition for this ...

  #+begin_src python
    # TODO: Set the `bound` to something more suitable once we
    # have proper shape support
    _ShapeType = TypeVar("_ShapeType", bound=Any)
    _ShapeType2 = TypeVar("_ShapeType2", bound=Any)
  #+end_src

  😭 Looks like we're stuck with ~Any~ which doesn't add any useful shape
  information on our types.

  But what if we don't want to wait for shape support in ~numpy~ 🤔? Luckily for
  us, [[https://peps.python.org/pep-0646/][PEP 646]] has the base foundation for shape typing and has already been
  accepted into python ~3.11~! And it's supported by ~pyright~! Theoretically
  these two things give us most of the ingredients to do basic shape typing.

  Now this blog post isn't about the details of [[https://peps.python.org/pep-0646/][PEP 646]] or variadic
  generics. But the rest of this post will assume you know the basics of how
  they work.

  In order to add rudimentary shape typing to ~numpy~ we can simply change the
  ~Any~ type in the ~NDArray~ type definition to an unpacked variadic generic
  like so:

  #+begin_src python
    ScalarType = TypeVar("ScalarType", bound=np.generic, covariant=True)
    Shape = TypeVarTuple("Shape")

    if TYPE_CHECKING or sys.version_info >= (3, 9):
        _DType = np.dtype[ScalarType]
        NDArray = np.ndarray[*Shape, np.dtype[ScalarType]]
    else:
        _DType = _GenericAlias(np.dtype, (ScalarType,))
        NDArray = _GenericAlias(np.ndarray, (Any, _DType))
  #+end_src

  Doing so allows us to fill in a ~Tuple~ based type (indicating array shape) in
  an ~NDArray~ alongside a ~dtype~ type. And by being able to type with
  ~Tuple~'s enables us define function overloads which describe to a type
  checker the possible ways a function can change the shape of an ~NDArray~.

  Let's try using these concepts to overloading a wrapper function for
  ~np.random.standard_normal~ from our ~Linear~ example:

  #+NAME: numpy-shape_typing-environment-start
  #+HEADER: :exports none
  #+begin_src bash :results verbatim :var NAME=(org-table-get-constant "container_name_shape_typing") IMAGE=(org-table-get-constant "image_name_shape_typing")
    echo "Running container if not already running ..."
    [ ! "$(podman ps | grep $NAME)" ] && \
      (podman run \
              -d \
              --name $NAME \
              --rm \
              -v $(pwd):/mnt \
              -w /mnt \
              -it $IMAGE sleep infinity; \
       echo "Container starting...") \
        || \
        echo "Container already running..."
  #+end_src

  #+RESULTS: numpy-shape_typing-environment-start
  : Running container if not already running ...
  : 3d870e0fd5fa2430fd4ed76984ac5cf58bd224aed492e5c51efe1dac4dfcc491
  : Container starting...

  #+NAME: setup-vars-shape-typing
  #+HEADER: :exports none
  #+begin_src emacs-lisp
    (setq org-babel-python-command "py")
    (setq py-default-interpreter "py")
  #+end_src

  #+RESULTS: setup-vars-shape-typing
  : py

  #+HEADER: :exports code :results output verbatim
  #+HEADER: :tangle bad_shape_typing.py
  #+begin_src python :dir (org-sbe container-dir-str-shape-typing)
    import numpy as np
    from numpy.typing import NDArray
    from typing import Tuple, TypeVar, Literal

    # shape typing boilerplate
    T1 = TypeVar("T1", bound=int)
    T2 = TypeVar("T2", bound=int)
    T3 = TypeVar("T3", bound=int)
    Shape = Tuple
    Shape1D = Shape[T1]
    Shape2D = Shape[T1, T2]
    Shape3D = Shape[T1, T2, T3]
    ShapeND = Shape[T1, ...]
    ShapeNDType = TypeVar("ShapeNDType", bound=ShapeND)

    def rand_normal_matrix(shape: ShapeNDType) -> NDArray[ShapeNDType, np.float64]:
        """Return a random ND normal matrix."""
        return np.random.standard_normal(size=shape)

    # Yay correct 2x2x2 cube!
    TWO = Literal[2]
    two_by_two_by_two: NDArray[Shape3D[TWO, TWO, TWO], np.float64] = rand_normal_matrix((2,2,2))
    print(two_by_two_by_two)

    COLS = Literal[10]
    ROWS = Literal[10]

    # Uh oh the shapes won't match!
    ten_by_ten: NDArray[Shape2D[COLS, ROWS], np.float64] = rand_normal_matrix((5,5))
    print(ten_by_ten)
  #+end_src

  #+RESULTS:
  #+begin_example
  [[[ 1.08383684 -0.93235767]
    [ 0.77370489 -0.23094173]]

   [[-0.36080346 -1.60719666]
    [-0.72917753  0.73126763]]]
  [[-0.1583864  -0.54168374 -1.05106127  0.44360795  1.67406833]
   [ 0.49748789  0.41599082  0.04458734  1.27599865 -0.44602015]
   [-0.1390734   0.75398734  0.82568951 -0.25329142 -1.40010258]
   [-0.62565285  1.06906175  1.14700824  1.06373754 -0.98659981]
   [-0.40292483 -0.40227061 -0.33068709  1.29622372 -2.94897423]]
  #+end_example

  Notice here there are no ~assert~ statements. And instead of several comments
  about shape, we indicate shape in the type hint.

  Now while this code is "runnable", ~pyright~ will tell us something else:

  #+NAME: pyright-bad-shape-typing
  #+HEADER: :results output
  #+begin_src bash :dir (org-sbe container-dir-str-shape-typing) :session pyright-shape-typing
    py -m pyright bad_shape_typing.py --lib
  #+end_src

  #+RESULTS: pyright-bad-shape-typing
  #+begin_example

  $ /opt/project/.venv/lib/python3.11/site-packages/nodeenv.py:26: DeprecationWarning: 'pipes' is deprecated and slated for removal in Python 3.13
    import pipes
   ,* Install prebuilt node (19.7.0) ..... done.
  No configuration file found.
  No pyproject.toml file found.
  stubPath /mnt/typings is not a valid directory.
  Assuming Python platform Linux
  Searching for source files
  Found 1 source file
  pyright 1.1.296
  /mnt/bad_shape_typing.py
    /mnt/bad_shape_typing.py:29:75 - error: Argument of type "tuple[Literal[5], Literal[5]]" cannot be assigned to parameter "shape" of type "ShapeNDType@rand_normal_matrix" in function "rand_normal_matrix"
      Type "Shape2D[COLS, ROWS]" cannot be assigned to type "tuple[Literal[5], Literal[5]]" (reportGeneralTypeIssues)
  1 error, 0 warnings, 0 informations
  Completed in 0.538sec
  #+end_example

  ~pyright~ is telling us we've incorrectly typed ~ten_by_ten~ and that it's
  incompatible with a ~5x5~ shape. Now we know we need to go back and fix the
  type to what a type checker should expect.

  Huzzah shape typing!!

* Moar ~numpy~ shape typing!

  Now that we have shape typed one function, let's step it up a notch. Let's try
  typing each ~numpy~ function in our ~Linear~ example to include shape
  types. We've already typed ~np.random.standard_normal~, so next let's do
  ~np.dot~.

  If we look at the [[https://numpy.org/doc/stable/reference/generated/numpy.dot.html][docs for ~np.dot~]] there are 5 type cases it supports (and
  only 4 we can implement).

  1. Both arguments as ~1D~ arrays

  2. Both arguments are ~2D~ arrays (resulting in a matmul)

  3. Either arguments are scalars

  4. Either arguments are ~ND~ arrays and the other argument is a ~1D~ array

  5. One argument is ~ND~ array and the other is ~MD~ array

  We can implement these cases as follows

  #+begin_src python :noeval
    ShapeVarGen = TypeVarTuple("ShapeVarGen")

    @overload
    def dot(x1: NDArray[Shape1D[T1], GenericDType], x2: NDArray[Shape1D[T1], GenericDType], /) -> GenericDType:
        ...


    @overload
    def dot(
        x1: NDArray[Shape[T1, *ShapeVarGen], GenericDType], x2: NDArray[Shape1D[T1], GenericDType], /
    ) -> NDArray[Shape[*ShapeVarGen], GenericDType]:
        ...


    @overload
    def dot(
        x1: NDArray[Shape2D[T1, T2], GenericDType],
        x2: NDArray[Shape2D[T2, T3], GenericDType],
        /,
    ) -> NDArray[Shape2D[T1, T3], GenericDType]:
        ...


    @overload
    def dot(x1: GenericDType, x2: GenericDType, /) -> GenericDType:
        ...


    def dot(x1, x2):
        return np.dot(x1, x2)

  #+end_src

  The only case we can't implement is an ~ND~ dimensional array with an ~MD~
  dimensional array. We would try implementing it like so:

  #+begin_src python :noeval
    ShapeVarGen1 = TypeVarTuple("ShapeVarGen1")
    ShapeVarGen2 = TypeVarTuple("ShapeVarGen2")

    @overload
    def dot(
        x1: NDArray[Shape[*ShapeVarGen1, T1], GenericDType], x2: NDArray[Shape[*ShapeVarGen2, T1, T2], GenericDType], /
    ) -> NDArray[Shape[*ShapeVarGen1, *ShapeVarGen2], GenericDType]:
        ...
  #+end_src

  But currently using multiple type variable tuples [[https://peps.python.org/pep-0646/#multiple-type-variable-tuples-not-allowed][is not allowed]]. If you know
  of another generic way to cover this case let me know! Luckily, our ~Linear~
  use case only uses scalars, vectors, and matrices which is covered by our
  overloads.

  Here's how we would use these ~dot~ overloads to do the dot product between a
  ~2x3~ matrix and a ~3x2~ matrix with type hints:

  #+HEADER: :exports both :results output
  #+HEADER: :tangle good_dot.py
  #+begin_src python :dir (org-sbe container-dir-str-shape-typing)
    import numpy as np
    from numpy.typing import NDArray
    from numpy_shape_typing.dot import dot
    from numpy_shape_typing.types import ShapeNDType, Shape2D
    from numpy_shape_typing.rand import rand_normal_matrix

    from typing import Literal

    TWO = Literal[2]
    THREE = Literal[3]
    A: NDArray[Shape2D[TWO, THREE], np.float64] = rand_normal_matrix((2,3))
    B: NDArray[Shape2D[THREE, TWO], np.float64] = rand_normal_matrix((3,2))
    C: NDArray[Shape2D[TWO, TWO], np.float64] = dot(A, B)
    print(C)
  #+end_src

  #+RESULTS:
  : [[-1.7426746   1.08235593]
  :  [ 1.80474815 -1.69172741]]

  And if we check with ~pyright~:

  #+NAME: pyright-good-dot
  #+HEADER: :results output
  #+begin_src bash :dir (org-sbe container-dir-str-shape-typing) :session pyright-shape-typing
    py -m pyright good_dot.py --lib
  #+end_src

  #+RESULTS: pyright-good-dot
  #+begin_example
  /opt/project/.venv/lib/python3.11/site-packages/nodeenv.py:26: DeprecationWarning: 'pipes' is deprecated and slated for removal in Python 3.13
    import pipes
   ,* Install prebuilt node (19.7.0) ..... done.
  No configuration file found.
  No pyproject.toml file found.
  stubPath /mnt/typings is not a valid directory.
  Assuming Python platform Linux
  Searching for source files
  Found 1 source file
  pyright 1.1.296
  0 errors, 0 warnings, 0 informations
  Completed in 0.553sec
  #+end_example

  Everything looks good as it should!

  And if we change the types to invalid matrix shapes:

  #+HEADER: :exports code :results output verbatim
  #+HEADER: :tangle bad_dot.py :noeval
  #+begin_src python
    import numpy as np
    from numpy.typing import NDArray
    from numpy_shape_typing.dot import dot
    from numpy_shape_typing.rand import rand_normal_matrix
    from numpy_shape_typing.types import ShapeNDType, Shape2D

    from typing import Literal

    TWO = Literal[2]
    THREE = Literal[3]
    FOUR = Literal[4]
    A: NDArray[Shape2D[TWO, THREE], np.float64] = rand_normal_matrix((2,3))
    B: NDArray[Shape2D[FOUR, FOUR], np.float64] = rand_normal_matrix((4,4))
    C: NDArray[Shape2D[TWO, TWO], np.float64] = dot(A, B)
    print(C)
  #+end_src

  #+RESULTS:

  #+NAME: pyright-bad-dot
  #+HEADER: :results output
  #+begin_src bash :dir (org-sbe container-dir-str-shape-typing) :session pyright-bad-shape-typing
    py -m pyright ./bad_dot.py --lib
  #+end_src

  #+RESULTS: pyright-bad-dot
  #+begin_example

  $ /opt/project/.venv/lib/python3.11/site-packages/nodeenv.py:26: DeprecationWarning: 'pipes' is deprecated and slated for removal in Python 3.13
    import pipes
   ,* Install prebuilt node (19.7.0) ..... done.
  No configuration file found.
  No pyproject.toml file found.
  stubPath /mnt/typings is not a valid directory.
  Assuming Python platform Linux
  Searching for source files
  Found 1 source file
  pyright 1.1.296
  /mnt/bad_dot.py
    /mnt/bad_dot.py:14:49 - error: Argument of type "NDArray[Shape2D[TWO, THREE], float64]" cannot be assigned to parameter "x1" of type "GenericDType@dot" in function "dot"
      Type "NDArray[Shape2D[TWO, THREE], float64]" cannot be assigned to type "NDArray[Shape2D[TWO, TWO], float64]"
        "NDArray[Shape2D[TWO, THREE], float64]" is incompatible with "NDArray[Shape2D[TWO, TWO], float64]"
          TypeVar "_ShapeType@ndarray" is invariant
            "*tuple[Shape2D[TWO, THREE]]" is incompatible with "*tuple[Shape2D[TWO, TWO]]"
              Tuple entry 1 is incorrect type (reportGeneralTypeIssues)
    /mnt/bad_dot.py:14:52 - error: Argument of type "NDArray[Shape2D[FOUR, FOUR], float64]" cannot be assigned to parameter "x2" of type "GenericDType@dot" in function "dot"
      Type "NDArray[Shape2D[FOUR, FOUR], float64]" cannot be assigned to type "NDArray[Shape2D[TWO, TWO], float64]"
        "NDArray[Shape2D[FOUR, FOUR], float64]" is incompatible with "NDArray[Shape2D[TWO, TWO], float64]"
          TypeVar "_ShapeType@ndarray" is invariant
            "*tuple[Shape2D[FOUR, FOUR]]" is incompatible with "*tuple[Shape2D[TWO, TWO]]"
              Tuple entry 1 is incorrect type (reportGeneralTypeIssues)
  2 errors, 0 warnings, 0 informations
  Completed in 0.561sec
  #+end_example

  ~pyright~ let's us know that the types we are using are incorrect based on the
  type overloads we've specified.

* Even moar ~numpy~ shape typing!

  The next function we are going to type is ~np.add~. The [[https://numpy.org/doc/stable/reference/generated/numpy.add.html][~numpy~ docs]] only show
  two cases.

  1. 2 ~ND~ array arguments of the same shape are added element wise

  2. 2 ~ND~ array arguments that are not the same shape must be broadcastable to
     a common shape

  Covering the first case is easy, but the second case is much harder as we
  would have to come up with a scheme to cover ~numpy~'s [[https://numpy.org/doc/stable/user/basics.broadcasting.html][array broadcasting
  system]]. However with a few overloads we can cover the broadcasting types for
  two dimensions.

  #+begin_src python :noeval
    from typing import overload

    import numpy as np
    from numpy.typing import NDArray

    from numpy_shape_typing.types import ONE, T1, T2, GenericDType, Shape1D, Shape2D, ShapeVarGen


    @overload
    def add(
        x1: NDArray[Shape2D[T1, T2], GenericDType],
        x2: NDArray[Shape1D[T2], GenericDType],
        /,
    ) -> NDArray[Shape2D[T1, T2], GenericDType]:
        ...


    @overload
    def add(
        x1: NDArray[Shape1D[T2], GenericDType],
        x2: NDArray[Shape2D[T1, T2], GenericDType],
        /,
    ) -> NDArray[Shape2D[T1, T2], GenericDType]:
        ...


    @overload
    def add(
        x1: NDArray[Shape2D[T1, T2], GenericDType],
        x2: NDArray[Shape1D[ONE], GenericDType],
        /,
    ) -> NDArray[Shape2D[T1, T2], GenericDType]:
        ...


    @overload
    def add(
        x1: NDArray[Shape1D[ONE], GenericDType],
        x2: NDArray[Shape2D[T1, T2], GenericDType],
        /,
    ) -> NDArray[Shape2D[T1, T2], GenericDType]:
        ...


    @overload
    def add(
        x1: NDArray[Shape2D[T1, T2], GenericDType],
        x2: NDArray[Shape2D[T1, ONE], GenericDType],
        /,
    ) -> NDArray[Shape2D[T1, T2], GenericDType]:
        ...


    @overload
    def add(
        x1: NDArray[Shape2D[T1, T2], GenericDType],
        x2: NDArray[Shape2D[ONE, T2], GenericDType],
        /,
    ) -> NDArray[Shape2D[T1, T2], GenericDType]:
        ...


    @overload
    def add(
        x1: NDArray[Shape2D[T1, ONE], GenericDType],
        x2: NDArray[Shape2D[T1, T2], GenericDType],
        /,
    ) -> NDArray[Shape2D[T1, T2], GenericDType]:
        ...


    @overload
    def add(
        x1: NDArray[Shape2D[ONE, T2], GenericDType],
        x2: NDArray[Shape2D[T1, T2], GenericDType],
        /,
    ) -> NDArray[Shape2D[T1, T2], GenericDType]:
        ...


    @overload
    def add(
        x1: GenericDType,
        x2: NDArray[Shape2D[T1, T2], GenericDType],
        /,
    ) -> NDArray[Shape2D[T1, T2], GenericDType]:
        ...


    @overload
    def add(
        x1: NDArray[Shape2D[T1, T2], GenericDType],
        x2: GenericDType,
        /,
    ) -> NDArray[Shape2D[T1, T2], GenericDType]:
        ...


    @overload
    def add(
        x1: NDArray[*ShapeVarGen, GenericDType],
        x2: NDArray[*ShapeVarGen, GenericDType],
        /,
    ) -> NDArray[*ShapeVarGen, GenericDType]:
        ...


    def add(x1, x2):
        return np.add(x1, x2)
  #+end_src

  Using these overloads, here is how we would catch unexpected array broadcasts
  (similar to the one from our original ~Linear~ example).


  #+HEADER: :exports code :results output verbatim
  #+HEADER: :tangle unnexpected_broadcast.py :noeval
  #+begin_src python
    from typing import Literal

    import numpy as np
    from numpy.typing import NDArray

    from numpy_shape_typing.add import add
    from numpy_shape_typing.dot import dot
    from numpy_shape_typing.rand import rand_normal_matrix
    from numpy_shape_typing.types import ONE, Shape1D, Shape2D

    FOUR = Literal[4]
    A: NDArray[Shape2D[FOUR, FOUR], np.float64] = rand_normal_matrix((4, 4))
    B: NDArray[Shape2D[ONE, FOUR], np.float64] = rand_normal_matrix((1, 4))
    C: NDArray[Shape2D[FOUR, ONE], np.float64] = add(A, B)
    print(C)
  #+end_src

  #+RESULTS:

  #+NAME: pyright-unexpected-broadcast
  #+HEADER: :results output
  #+begin_src bash :dir (org-sbe container-dir-str-shape-typing) :session pyright-bad-shape-typing
    py -m pyright unnexpected_broadcast.py --lib
  #+end_src

  #+RESULTS: pyright-unexpected-broadcast
  #+begin_example
  /opt/project/.venv/lib/python3.11/site-packages/nodeenv.py:26: DeprecationWarning: 'pipes' is deprecated and slated for removal in Python 3.13
    import pipes
   ,* Install prebuilt node (19.7.0) ..... done.
  No configuration file found.
  No pyproject.toml file found.
  stubPath /mnt/typings is not a valid directory.
  Assuming Python platform Linux
  Searching for source files
  Found 1 source file
  pyright 1.1.296
  /mnt/unnexpected_broadcast.py
    /mnt/unnexpected_broadcast.py:14:50 - error: Argument of type "NDArray[Shape2D[FOUR, FOUR], float64]" cannot be assigned to parameter "x1" of type "NDArray[*ShapeVarGen@add, GenericDType@add]" in function "add"
      "NDArray[Shape2D[FOUR, FOUR], float64]" is incompatible with "NDArray[Shape2D[FOUR, ONE], float64]"
        TypeVar "_ShapeType@ndarray" is invariant
          "*tuple[Shape2D[FOUR, FOUR]]" is incompatible with "*tuple[Shape2D[FOUR, ONE]]"
            Tuple entry 1 is incorrect type
              "Shape2D[FOUR, FOUR]" is incompatible with "Shape2D[FOUR, ONE]" (reportGeneralTypeIssues)
    /mnt/unnexpected_broadcast.py:14:53 - error: Argument of type "NDArray[Shape2D[ONE, FOUR], float64]" cannot be assigned to parameter "x2" of type "NDArray[*ShapeVarGen@add, GenericDType@add]" in function "add"
      "NDArray[Shape2D[ONE, FOUR], float64]" is incompatible with "NDArray[Shape2D[FOUR, ONE], float64]"
        TypeVar "_ShapeType@ndarray" is invariant
          "*tuple[Shape2D[ONE, FOUR]]" is incompatible with "*tuple[Shape2D[FOUR, ONE]]"
            Tuple entry 1 is incorrect type
              "Shape2D[ONE, FOUR]" is incompatible with "Shape2D[FOUR, ONE]" (reportGeneralTypeIssues)
  2 errors, 0 warnings, 0 informations
  Completed in 0.579sec
  #+end_example

  -----

  And now the last function we will type to complete our example is
  ~np.ravel~. However this is where we reach the limitations of shape typing as
  they exist today in ~python~ and ~numpy~.

  Ideally we would try to write code like this:

  #+begin_src python :noeval
    ShapeVarGen = TypeVarTuple("ShapeVarGen")

    @overload
    def ravel(
        arr: NDArray[Shape[*ShapeVarGen], GenericDType]
    ) -> NDArray[Shape1D[Product[*ShapeVarGen]], GenericDType]:
        ...
  #+end_src

  In order to generically type ~np.ravel~ we need a way to find the product of
  every dimensions size. But ~python~ currently doesn't provide a way to do
  algebraic typing like this.

  However for the sake of completing our ~Linear~ example we can "fake"
  type ~np.ravel~:




  For more information about shape typing checkout:

  1. [[https://docs.google.com/document/d/1But-hjet8-djv519HEKvBN6Ik2lW3yu0ojZo6pG9osY/edit#heading=h.aw3bt3fg1s2w][This google doc on a shape typing syntax proposal]] by Matthew Rahtz, Jörg
     Bornschein, Vlad Mikulik, Tim Harley, Matthew Willson, Dimitrios
     Vytiniotis, Sergei Lebedev, Adam Paszke



  #+HEADER: :exports code :results output verbatim
  #+HEADER: :tangle raveling.py :noeval
  #+begin_src python
    import numpy as np
    from numpy.typing import NDArray

    from numpy_shape_typing.rand import rand_normal_matrix
    from numpy_shape_typing.ravel import ravel
    from numpy_shape_typing.types import FOUR, SEVEN, TWO, Shape1D, Shape2D

    A: NDArray[Shape2D[TWO, FOUR], np.float64] = rand_normal_matrix((2, 4))
    B: NDArray[Shape1D[SEVEN], np.float64] = ravel(A)
    print(B)
  #+end_src

  #+RESULTS:

  #+NAME: pyright-raveling
  #+HEADER: :results output
  #+begin_src bash :dir (org-sbe container-dir-str-shape-typing) :session pyright-bad-shape-typing
    py -m pyright raveling.py --lib
  #+end_src

  #+RESULTS: pyright-raveling
  #+begin_example
  /opt/project/.venv/lib/python3.11/site-packages/nodeenv.py:26: DeprecationWarning: 'pipes' is deprecated and slated for removal in Python 3.13
    import pipes
   ,* Install prebuilt node (19.7.0) ..... done.
  No configuration file found.
  No pyproject.toml file found.
  stubPath /mnt/typings is not a valid directory.
  Assuming Python platform Linux
  Searching for source files
  Found 1 source file
  pyright 1.1.296
  /mnt/raveling.py
    /mnt/raveling.py:9:42 - error: Expression of type "NDArray[Shape1D[EIGHT], float64]" cannot be assigned to declared type "NDArray[Shape1D[SEVEN], float64]"
      "NDArray[Shape1D[EIGHT], float64]" is incompatible with "NDArray[Shape1D[SEVEN], float64]"
        TypeVar "_ShapeType@ndarray" is invariant
          "*tuple[Shape1D[EIGHT]]" is incompatible with "*tuple[Shape1D[SEVEN]]"
            Tuple entry 1 is incorrect type
              "Shape1D[EIGHT]" is incompatible with "Shape1D[SEVEN]" (reportGeneralTypeIssues)
  1 error, 0 warnings, 0 informations
  Completed in 0.559sec
  #+end_example
