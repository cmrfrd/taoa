#+TITLE: Shape typing numpy with pyright and variadic generics
#+CREATED: <2023-02-27 Mon>
#+LAST_MODIFIED: [2023-03-12 Sun 13:02]
#+ROAM_TAGS: composition
#+OPTIONS: toc:nil
#+OPTIONS: tex:t
#+OPTIONS: _:nil ^:nil p:nil

#+HUGO_BASE_DIR: ./
#+hugo_front_matter_format: yaml
#+HUGO_CUSTOM_FRONT_MATTER: :date (org-to-blog-date (org-global-prop-value "CREATED"))
#+HUGO_CUSTOM_FRONT_MATTER: :hero ./images/cover.jpg
#+HUGO_CUSTOM_FRONT_MATTER: :secret false
#+HUGO_CUSTOM_FRONT_MATTER: :excerpt MxN * NxM

#+BEGIN_SRC emacs-lisp :exports none
  (defun org-hugo-link (link contents info) (org-md-link link contents info))

  ;; Setup org/latex exporting
  (add-to-list 'org-export-filter-latex-fragment-functions
               'sub-paren-for-dollar-sign)
  (add-to-list 'org-export-filter-headline-functions
               'remove-regexp-curly-braces)
  (add-to-list 'org-export-filter-latex-environment-functions
               'sub-paren-for-dollar-sign)
  (export-to-mdx-on-save)
#+END_SRC

#+RESULTS:
: Enabled mdx on save


When doing any sort of tensor/array computation in python (via ~numpy~,
~pytorch~, ~jax~, or other>>), it's more frequent than not to encounter shape
errors like the one below

  #+CONSTANTS: image_name=pyright container_name=pyright
  #+CONSTANTS: image_name_shape_typing=cmrfrd/numpy_shape_typing-dev container_name_shape_typing=numpy_shape_typing-dev

  #+NAME: setup-vars
  #+HEADER: :exports none
  #+begin_src emacs-lisp
    (setq docker-tramp-docker-executable "podman")
    (docker-tramp-add-method)
    (setq org-babel-inline-result-wrap "$%s$")
    (setq shutdown-env nil)
    (setq ob-ipython-command "python")
    (setq org-babel-python-command "python")
    (setq py-default-interpreter "python")
  #+end_src

  #+RESULTS: setup-vars
  : python

  #+NAME: container-dir-str
  #+HEADER: :exports none
  #+begin_src emacs-lisp
    (setq container-dir-str (format "/docker:root@%s:/mnt" (org-table-get-constant "container_name")))
  #+end_src

  #+RESULTS: container-dir-str
  : /docker:root@pyright:/mnt

  #+NAME: container-dir-str-shape-typing
  #+HEADER: :exports none
  #+begin_src emacs-lisp
    (setq container-dir-str-shape-typing (format "/docker:user@%s:/mnt" (org-table-get-constant "container_name_shape_typing")))
  #+end_src

  #+RESULTS: container-dir-str-shape-typing
  : /docker:user@numpy_shape_typing-dev:/mnt

  #+NAME: container-dir-str-shape-typing-project
  #+HEADER: :exports none
  #+begin_src emacs-lisp
    (setq container-dir-str-shape-typing-project (format "/docker:user@%s:/opt/project" (org-table-get-constant "container_name_shape_typing")))
  #+end_src

  #+RESULTS: container-dir-str-shape-typing-project
  : /docker:user@numpy_shape_typing-dev:/opt/project

  #+NAME: init
  #+HEADER: :exports none :results output
  #+begin_src python :session numpy
    print("init")
  #+end_src

  #+RESULTS: init
  : init

  #+HEADER: :exports both :results output verbatim
  #+begin_src python :session numpy
    import numpy as np

    size1 = (2,3)
    size2 = (4,3)

    M1 = np.random.random(size=size1)
    M2 = np.random.random(size=size2)

    try:
        print(np.dot(M1,M2))
    except Exception as e:
        print(e)
  #+end_src

  #+RESULTS:
  : shapes (2,3) and (4,3) not aligned: 3 (dim 1) != 4 (dim 0)

  And most of the time, these kind of errors boil down to something like
  accidentally forgetting to do a reshape or transpose like so.

  #+HEADER: :exports both :results output verbatim
  #+begin_src python :session numpy
    import numpy as np

    size1 = (2,3)
    size2 = (4,3)

    M1 = np.random.random(size=size1)
    M2 = np.random.random(size=size2).T

    try:
        print(np.dot(M1,M2))
    except Exception as e:
        print(e)
  #+end_src

  #+RESULTS:
  : [[0.1547545  0.30949099 0.59024794 0.55318775]
  :  [0.21051272 0.34419557 0.54559747 0.5703837 ]]

  And while this is a mild case, shape bugs like these become more frequent as
  operations grow more complex and as more dimensions are involved.

  Here's a slightly more complex example of a ~Linear~ implementation in ~numpy~
  with a subtle shape bug.

  #+HEADER: :exports both :results output verbatim
  #+begin_src python :session numpy
    def Linear(A, x, b):
        """
        Takes matrix A (m x n) times a vector x (n x 1) and
        adds a bias. The resulting ndarray is then ravelled
        into a vector of size (m).
        """
        Ax = np.dot(A, x)
        Axb = np.add(Ax, b)
        return np.ravel(Axb)

    A = np.random.random(size=(4,4))
    x = np.random.random(size=(4,1))
    b = np.random.random(size=(4))

    result = Linear(A, x, b)
    print(result)
    print(result.shape)
  #+end_src

  #+RESULTS:
  : [1.73515224 1.89505469 1.9289733  1.72298648 1.60409676 1.76399922
  :  1.79791782 1.59193101 0.58554031 0.74544276 0.77936137 0.57337455
  :  0.98373656 1.14363901 1.17755762 0.9715708 ]
  : (16,)


  The docstring of ~Linear~ clearly says the result should be size ~m~ (or
  ~4~). But why then did we end up with a vector of size ~16~? If we dig into
  each function we will eventually find that our problem is in how ~numpy~
  handles an ~ndarray~ of a different shape.

  If we break down ~Linear~, after ~np.dot~ we have an ~ndarray~ of shape
  ~(4,1)~ of which we do ~np.add~ with a vector of shape ~(4)~. And here lies
  our bug. We might naturally think that ~np.add~ will do this addition element
  wise, but instead we fell into an [[https://numpy.org/doc/stable/user/basics.broadcasting.html#broadcastable-arrays][array broadcasting]] trap. Array broadcasting
  are sets of rules ~numpy~ uses to determine how to do arithmetic on different
  shaped ~ndarrays~. So instead of doing our computation element wise, ~numpy~
  interprets this as doing a broadcast operation of addition, resulting in a
  ~(4,4)~ matrix, which subsequently gets "raveled" into a size ~16~ vector.

  Now to fix this is easy, we just need to initialize our ~b~ variable to be of
  shape ~(4,1)~ so ~numpy~ will interpret the ~np.add~ as an element wise
  addition.

  #+HEADER: :exports both :results output verbatim
  #+begin_src python :session numpy
    def Linear(A, x, b):
        """
        Takes matrix A (m x n) times a vector x (n x 1) and
        adds a bias. The resulting ndarray is then ravelled
        into a vector of size (m).
        """
        Ax = np.dot(A, x)
        Axb = np.add(Ax, b)
        return np.ravel(Axb)

    A = np.random.random(size=(4,4))
    x = np.random.random(size=(4,1))
    b = np.random.random(size=(4,1))

    result = Linear(A, x, b)
    print(result)
    print(result.shape)
  #+end_src

  #+RESULTS:
  : [0.66736135 0.75746147 1.53202375 1.56823255]
  : (4,)

  We've solved the problem, but how can we be smarter to prevent this error from
  happening again?

* Existing ways to stop shape bugs

  The simplest way we can try to stop this shape bug is with good docs. Ideally
  we should always have good docs, but we can make it a point to include what
  the shape expectations are like so:

  #+HEADER: :exports code :results output verbatim
  #+begin_src python :session numpy
    def Linear(A, x, b):
        """
        Args:
            A: ndarray of shape (M x N)
            x: ndarray of shape (N x 1)
            b: ndarray of shape (M x 1)

        Returns:
            Linear output ndarray of shape (M)
        """
        Ax = np.dot(A, x) # Shape (M x 1)
        Axb = np.add(Ax, b) # (M x 1) + (M x 1)
        return np.ravel(Axb) # Shape (M)
  #+end_src

  #+RESULTS:

  #+RESULTS: linear-good-docs

  Now while informative, nothing is preventing us from encountering the same bug
  again. The only benefit this gives us, is making the debugging process a
  bit easier.

  We can do better.

  Another approach in addition to good docs that's more of a preventative action
  is to use assertions. By sprinkling ~assert~ throughout ~Linear~ with an
  informative error message, we can "fail early" and start debugging like so:

  #+HEADER: :exports code :results output verbatim
  #+begin_src python :session numpy
    def Linear(A, x, b):
        """
        Args:
            A: ndarray of shape (M x N)
            x: ndarray of shape (N x 1)
            b: ndarray of shape (M x 1)

        Returns:
            Linear output ndarray of shape (M)
        """
        assert len(A.shape) == 2, f"A must be of dim 2, not {len(A.shape)}"
        Am, An = A.shape

        assert x.shape == (An, 1), f"X must be shape ({An}, 1) to do dot"
        Ax = np.dot(A, x) # Shape (M x 1)

        assert b.shape == (Am, 1), f"Bias term must be shape ({Am}, 1)"
        result = np.add(Ax, b) # (M x 1) + (M x 1)

        ravel_result = np.ravel(result)
        assert ravel_result.shape == (Am,), f"Uh oh, ravel result is shape {ravel_result.shape} and not {(Am,)}"
        return ravel_result
  #+end_src

  #+RESULTS:


  At every step of this function we do an ~assert~ to make sure all the
  ~ndarray~ shapes are what we expect.

  As a result ~Linear~ is a bit "safer". But compared to what we had originally,
  this approach is much less readable. We also inherit some of the baggage that
  comes with runtime error checking like:

  - *Incomplete checking*: Have we checked all expected shape failure modes?

  - *Slow debugging cycles*: How many refactor->run cycles will we have to do
    pass the checks?

  - *Additional testing*: Do we have to update our tests cover our runtime error
    checks?

  Overall runtime error checking is not a bad thing. In most cases it's very
  necessary! But when it comes to shape errors, we can leverage an additional
  approach, static type checking.

  Even though ~python~ is a dynamically typed language, in ~python>=3.5~ the
  ~typing~ module was introduced to enable static type checkers to validate type
  hinted ~python~ code. (See [[https://www.youtube.com/watch?v=2wDvzy6Hgxg][this video]] for more details)

  Over time many third party libraries (like ~numpy~) have started to type hint
  their codebases which we can use to our benefit.

  In order to help us prevent shape errors, let's see what typing capabilities
  exist in ~numpy~.

* ~dtype~ typing ~numpy~ arrays

  As of writing this post, ~numpy==v1.24.2~ only supports typing on an
  ~ndarray~'s ~dtype~ (~uint8~, ~float64~, etc.).

  Using ~numpy~'s existing type hinting tooling, here's how we would include
  ~dtype~ type information to our ~Linear~ example (note: there is an
  intentional type error)

  #+HEADER: :exports both :results output verbatim :tangle linear_bad_typing.py
  #+begin_src python :session numpy
    from typing import TypeVar

    import numpy as np
    from numpy.typing import NDArray

    GenericType = TypeVar("GenericType", bound=np.generic)


    def Linear(
            A: NDArray[GenericType],
            x: NDArray[GenericType],
            b: NDArray[GenericType],
    ) -> NDArray[GenericType]:
        """
        Args:
            A: ndarray of shape (M x N)
            x: ndarray of shape (N x 1)
            b: ndarray of shape (M x 1)

        Returns:

            Linear output ndarray of shape (M)
        """
        assert len(A.shape) == 2, f"A must be of dim 2, not {len(A.shape)}"
        Am, An = A.shape

        assert x.shape == (An, 1), f"X must be shape ({An}, 1) to do dot"
        Ax: NDArray[GenericType] = np.dot(A, x)  # Shape (M x 1)

        assert b.shape == (Am, 1), f"Bias term must be shape ({Am}, 1)"
        result: NDArray[GenericType] = np.add(Ax, b)  # (M x 1) + (M x 1)

        ravel_result: NDArray[GenericType] = np.ravel(result)
        assert ravel_result.shape == (Am,), f"Uh oh, ravel result is shape {ravel_result.shape} and not {(Am,)}"
        return ravel_result


    A: NDArray[np.float64] = np.random.standard_normal(size=(10, 10))
    x: NDArray[np.float64] = np.random.standard_normal(size=(10, 1))
    b: NDArray[np.float32] = np.random.standard_normal(size=(10, 1))
    y: NDArray[np.float64] = Linear(A, x, b)
    print(y)
    print(y.dtype)
  #+end_src

  #+RESULTS:
  : [ 2.46238575 -3.14896089 -1.94370608 -1.15712163 -0.1701296   1.25522833
  :  -3.73717187 -0.03529537  2.88735514  2.50981703]
  : float64


  #+NAME: pyright-environment-build
  #+HEADER: :exports none :padline no
  #+BEGIN_SRC podman-build :dir "." :tangle (make-temp-name "Dockerfile-") :tag (org-table-get-constant "image_name")
    FROM python:3.11.2-slim
    USER root
    RUN pip install pyright numpy
    CMD ["sleep", "infinity"]
  #+END_SRC

  #+RESULTS: pyright-environment-build
  : #<window 614 on /tmp/babel-nU1TQb/ob-podman-build-out-3Te4yf>

  #+NAME: pyright-environment-start
  #+HEADER: :exports none
  #+begin_src bash :results verbatim :var NAME=(org-table-get-constant "container_name")
    echo "Running container if not already running ..."
    [ ! "$(podman ps | grep $NAME)" ] && \
      (podman run \
              -d \
              --name $NAME \
              --rm \
              -v $(pwd):/mnt \
              -w /mnt \
              -it pyright:latest; \
       echo "Container starting...") \
        || \
        echo "Container already running..."
  #+end_src

  #+RESULTS: pyright-environment-start
  : Running container if not already running ...
  : Container already running...

  Even though this code is "runnable" and doesn't produce an error, a type
  checker like ~pyright~ tells us a different story.

  #+HEADER: :results output
  #+begin_src bash :dir (org-sbe container-dir-str) :session pyright
    pyright linear_bad_typing.py
  #+end_src

  #+RESULTS:
  #+begin_example
  STEP 1/4: FROM python:3.11.2-slim
  STEP 2/4: USER root
  Using cache 0948b45cbff93ee6c26fd2f25cd97e5d1be44ee05d33f69bbcc03e6995287819
  0948b45cbff
  STEP 3/4: RUN pip install pyright numpy
  Using cache cd7565c67e85715a5648c30e62672b6b9c7580751961cb9a598f867c1e199b99
  cd7565c67e8
  STEP 4/4: CMD ["sleep", "infinity"]
  Using cache f4506a0d8337c9b96ef850c295add506621ead2997aa6d166eac40d48c88e222
  COMMIT pyright
  v1.1.298).
  Please install the new version or set PYRIGHT_PYTHON_FORCE_VERSION to `latest`
  f4506a0d833
  Successfully tagged localhost/pyright:latest
  f4506a0d8337c9b96ef850c295add506621ead2997aa6d166eac40d48c88e222
  No configuration file found.
  No pyproject.toml file found.
  stubPath /mnt/typings is not a valid directory.
  Assuming Python platform Linux
  Searching for source files
  Found 1 source file
  pyright 1.1.296
  /mnt/linear_bad_typing.py
    /mnt/linear_bad_typing.py:40:26 - error: Expression of type "ndarray[Any, dtype[float64]]" cannot be assigned to declared type "NDArray[float32]"
    Â Â "ndarray[Any, dtype[float64]]" is incompatible with "NDArray[float32]"
    Â Â Â Â TypeVar "_DType_co@ndarray" is covariant
    Â Â Â Â Â Â "dtype[float64]" is incompatible with "dtype[float32]"
    Â Â Â Â Â Â Â Â TypeVar "_DTypeScalar_co@dtype" is covariant
    Â Â Â Â Â Â Â Â Â Â "float64" is incompatible with "float32" (reportGeneralTypeIssues)
    /mnt/linear_bad_typing.py:41:39 - error: Argument of type "NDArray[float32]" cannot be assigned to parameter "b" of type "NDArray[GenericType@Linear]" in function "Linear"
    Â Â "NDArray[float32]" is incompatible with "NDArray[float64]"
    Â Â Â Â TypeVar "_DType_co@ndarray" is covariant
    Â Â Â Â Â Â "dtype[float32]" is incompatible with "dtype[float64]"
    Â Â Â Â Â Â Â Â TypeVar "_DTypeScalar_co@dtype" is covariant
    Â Â Â Â Â Â Â Â Â Â "float32" is incompatible with "float64" (reportGeneralTypeIssues)
  2 errors, 0 warnings, 0 informations
  Completed in 0.623sec
  #+end_example

  ~pyright~ has noticed that when we create our ~b~ variable, we gave it a
  ~dtype~ type that is incompatible with ~np.random.standard_normal~.

  Now we know to adjust the type hint of ~b~ to be in line with the ~dtype~ that
  is expected of ~np.random.standard_normal~ (~NDArray[np.float64]~).

* Shape typing ~numpy~ arrays

  While ~dtype~ typing is great, it's not the most useful for preventing shape
  errors (like from our original example).

  Ideally it would be great if in addition to a ~dtype~ type, we can also
  include information about an ~ndarray~'s shape to do shape typing.

  Shape typing is a technique used to annotate information about the
  dimensionality and size of an array. In the context of ~numpy~ and the
  ~python~ type hinting system, we can use shape typing catch shape errors
  before runtime.

  #+begin_quote
  For more information about shape typing checkout [[https://docs.google.com/document/d/1But-hjet8-djv519HEKvBN6Ik2lW3yu0ojZo6pG9osY/edit#heading=h.aw3bt3fg1s2w][this google doc on a shape
  typing syntax proposal]] by Matthew Rahtz, JÃ¶rg Bornschein, Vlad Mikulik, Tim
  Harley, Matthew Willson, Dimitrios Vytiniotis, Sergei Lebedev, Adam Paszke.
  #+end_quote

  As we've seen, ~numpy~'s ~NDArray~ currently only supports ~dtype~ typing and
  doesn't have any of this kind of shape typing ability. But why is that? If we
  dig into the definition of the ~NDArray~ type:

  #+begin_src python
    ScalarType = TypeVar("ScalarType", bound=np.generic, covariant=True)

    if TYPE_CHECKING or sys.version_info >= (3, 9):
        _DType = np.dtype[ScalarType]
        NDArray = np.ndarray[Any, np.dtype[ScalarType]]
    else:
        _DType = _GenericAlias(np.dtype, (ScalarType,))
        NDArray = _GenericAlias(np.ndarray, (Any, _DType))
  #+end_src

  #+RESULTS:

  And follow the definition of ~np.ndarray~ ...

  #+begin_src python
    class ndarray(_ArrayOrScalarCommon, Generic[_ShapeType, _DType_co]):
  #+end_src

  #+RESULTS:

  We can see that it looks like ~numpy~ uses a ~Shape~ type already! But
  unfortunately if we look at the definition for this ...

  #+begin_src python
    # TODO: Set the `bound` to something more suitable once we
    # have proper shape support
    _ShapeType = TypeVar("_ShapeType", bound=Any)
    _ShapeType2 = TypeVar("_ShapeType2", bound=Any)
  #+end_src

  #+RESULTS:

  ðŸ˜­ Looks like we're stuck with ~Any~ which doesn't add any useful shape
  information on our types.

  Luckily for us, we don't have to wait for shape support in ~numpy~. [[https://peps.python.org/pep-0646/][PEP 646]] has
  the base foundation for shape typing and has already been accepted into python
  ~3.11~! And it's supported by ~pyright~! Theoretically these two things give
  us most of the ingredients to do basic shape typing.

  Now this blog post isn't about the details of [[https://peps.python.org/pep-0646/][PEP 646]] or variadic
  generics. But the rest of this post will assume you know the basics of how
  they work.

  In order to add rudimentary shape typing to ~numpy~ we can simply change the
  ~Any~ type in the ~NDArray~ type definition to an unpacked variadic generic
  like so:

  #+begin_src python
    ScalarType = TypeVar("ScalarType", bound=np.generic, covariant=True)
    Shape = TypeVarTuple("Shape")

    if TYPE_CHECKING or sys.version_info >= (3, 9):
        _DType = np.dtype[ScalarType]
        NDArray = np.ndarray[*Shape, np.dtype[ScalarType]]
    else:
        _DType = _GenericAlias(np.dtype, (ScalarType,))
        NDArray = _GenericAlias(np.ndarray, (Any, _DType))
  #+end_src

  #+RESULTS:

  Doing so allows us to fill in a ~Tuple~ based type (indicating shape) in an
  ~NDArray~ alongside a ~dtype~ type. And shape typing with ~Tuple~'s enables us
  define function overloads which describe to a type checker the possible ways a
  function can change the shape of an ~NDArray~.

  Let's look at an example of using these concepts to type a wrapper function
  for ~np.random.standard_normal~ from our ~Linear~ example with an intentional
  type error:

  #+NAME: numpy-shape_typing-environment-start
  #+HEADER: :exports none
  #+begin_src bash :results verbatim :var NAME=(org-table-get-constant "container_name_shape_typing") IMAGE=(org-table-get-constant "image_name_shape_typing")
    echo "Running container if not already running ..."
    [ ! "$(podman ps | grep $NAME)" ] && \
      (podman run \
              -d \
              --name $NAME \
              --rm \
              -v $(pwd):/mnt \
              -w /mnt \
              -it $IMAGE sleep infinity; \
       echo "Container starting...") \
        || \
        echo "Container already running..."
  #+end_src

  #+RESULTS: numpy-shape_typing-environment-start
  : Running container if not already running ...
  : Container already running...

  #+NAME: setup-vars-shape-typing
  #+HEADER: :exports none
  #+begin_src emacs-lisp
    (setq org-babel-python-command "py")
    (setq py-default-interpreter "py")
  #+end_src

  #+RESULTS: setup-vars-shape-typing
  : py

  #+HEADER: :exports both :results output verbatim
  #+HEADER: :tangle bad_shape_typing.py
  #+begin_src python :dir (org-sbe container-dir-str-shape-typing)
    import numpy as np
    from numpy.typing import NDArray
    from typing import Tuple, TypeVar, Literal

    # Generic dimension sizes types
    T1 = TypeVar("T1", bound=int)
    T2 = TypeVar("T2", bound=int)
    T3 = TypeVar("T3", bound=int)

    # Dimension types represented as typles
    Shape = Tuple
    Shape1D = Shape[T1]
    Shape2D = Shape[T1, T2]
    Shape3D = Shape[T1, T2, T3]
    ShapeND = Shape[T1, ...]
    ShapeNDType = TypeVar("ShapeNDType", bound=ShapeND)

    def rand_normal_matrix(shape: ShapeNDType) -> NDArray[ShapeNDType, np.float64]:
        """Return a random ND normal matrix."""
        return np.random.standard_normal(size=shape)

    # Yay correctly typed 2x2x2 cube!
    TWO = Literal[2]
    two_by_two_by_two: NDArray[Shape3D[TWO, TWO, TWO], np.float64] = rand_normal_matrix((2,2,2))
    print(two_by_two_by_two)

    FOUR = Literal[4]

    # Uh oh the shapes won't match!
    four_by_four: NDArray[Shape2D[FOUR, FOUR], np.float64] = rand_normal_matrix((3,3))
    print(four_by_four)
  #+end_src

  #+RESULTS:
  : [[[-0.25349245  0.48769158]
  :   [ 0.71369366  1.87259878]]
  :
  :  [[ 1.16757851 -0.71031436]
  :   [-0.68083206  0.49385056]]]
  : [[-1.23500485 -0.97530914 -0.01870734]
  :  [ 0.50789676  1.31297228  2.11942613]
  :  [-0.44229871  1.02762774  0.75637794]]

  Notice here there are no ~assert~ statements. And instead of several comments
  about shape, we indicate shape in the type hint.

  Now while this code is "runnable", ~pyright~ will tell us something else:

  #+HEADER: :results output
  #+begin_src bash :dir (org-sbe container-dir-str-shape-typing) :session pyright-shape-typing
    py -m pyright bad_shape_typing.py --lib
  #+end_src

  #+RESULTS:
  #+begin_example
  /opt/project/.venv/lib/python3.11/site-packages/nodeenv.py:26: DeprecationWarning: 'pipes' is deprecated and slated for removal in Python 3.13
    import pipes
   ,* Install prebuilt node (19.7.0) ..... done.
  No configuration file found.
  No pyproject.toml file found.
  stubPath /mnt/typings is not a valid directory.
  Assuming Python platform Linux
  Searching for source files
  Found 1 source file
  pyright 1.1.298
  /mnt/bad_shape_typing.py
    /mnt/bad_shape_typing.py:30:77 - error: Argument of type "tuple[Literal[3], Literal[3]]" cannot be assigned to parameter "shape" of type "ShapeNDType@rand_normal_matrix" in function "rand_normal_matrix"
    Â Â Type "Shape2D[FOUR, FOUR]" cannot be assigned to type "tuple[Literal[3], Literal[3]]" (reportGeneralTypeIssues)
  1 error, 0 warnings, 0 informations
  Completed in 0.541sec
  #+end_example

  ~pyright~ is telling us we've incorrectly typed ~four_by_four~ and that it's
  incompatible with a ~3x3~ shape. Now we know we need to go back and fix the
  type to what a type checker should expect.

  Huzzah shape typing!!

* Moar ~numpy~ shape typing!

  Now that we have shape typed one function, let's step it up a notch. Let's try
  typing each ~numpy~ function in our ~Linear~ example to include shape
  types. We've already typed ~np.random.standard_normal~, so next let's do
  ~np.dot~.

  If we look at the [[https://numpy.org/doc/stable/reference/generated/numpy.dot.html][docs for ~np.dot~]] there are 5 type cases it supports.

  1. Both arguments as ~1D~ arrays

  2. Both arguments are ~2D~ arrays (resulting in a ~matmul~)

  3. Either arguments are scalars

  4. Either argument is a ~ND~ array and the other is a ~1D~ array

  5. One argument is ~ND~ array and the other is ~MD~ array

  We can implement these cases as follows

  #+HEADER: :exports code
  #+begin_src python :noeval
    ShapeVarGen = TypeVarTuple("ShapeVarGen")

    @overload
    def dot(x1: NDArray[Shape1D[T1], GenericDType], x2: NDArray[Shape1D[T1], GenericDType], /) -> GenericDType:
        ...


    @overload
    def dot(
        x1: NDArray[Shape[T1, *ShapeVarGen], GenericDType], x2: NDArray[Shape1D[T1], GenericDType], /
    ) -> NDArray[Shape[*ShapeVarGen], GenericDType]:
        ...


    @overload
    def dot(
        x1: NDArray[Shape2D[T1, T2], GenericDType],
        x2: NDArray[Shape2D[T2, T3], GenericDType],
        /,
    ) -> NDArray[Shape2D[T1, T3], GenericDType]:
        ...


    @overload
    def dot(x1: GenericDType, x2: GenericDType, /) -> GenericDType:
        ...


    def dot(x1, x2):
        return np.dot(x1, x2)

  #+end_src

  The only case we can't implement is an ~ND~ dimensional array with an ~MD~
  dimensional array. Ideally we would try implementing it like so:

  #+HEADER: :exports code
  #+begin_src python :noeval
    ShapeVarGen1 = TypeVarTuple("ShapeVarGen1")
    ShapeVarGen2 = TypeVarTuple("ShapeVarGen2")

    @overload
    def dot(
        x1: NDArray[Shape[*ShapeVarGen1, T1], GenericDType], x2: NDArray[Shape[*ShapeVarGen2, T1, T2], GenericDType], /
    ) -> NDArray[Shape[*ShapeVarGen1, *ShapeVarGen2], GenericDType]:
        ...
  #+end_src

  But currently using multiple type variable tuples [[https://peps.python.org/pep-0646/#multiple-type-variable-tuples-not-allowed][is not allowed]]. If you know
  of another way to cover this case let me know! Luckily for our ~Linear~ use
  case, it only uses scalars, vectors, and matrices which is covered by our four
  overloads.

  Here's how we would use these ~dot~ overloads to do the dot product between a
  ~2x3~ matrix and a ~3x2~ matrix with type hints:

  #+HEADER: :exports both :results output
  #+HEADER: :tangle good_dot.py
  #+begin_src python :dir (org-sbe container-dir-str-shape-typing)
    import numpy as np
    from numpy.typing import NDArray
    from numpy_shape_typing.dot import dot
    from numpy_shape_typing.types import ShapeNDType, Shape2D
    from numpy_shape_typing.rand import rand_normal_matrix

    from typing import Literal

    TWO = Literal[2]
    THREE = Literal[3]
    A: NDArray[Shape2D[TWO, THREE], np.float64] = rand_normal_matrix((2,3))
    B: NDArray[Shape2D[THREE, TWO], np.float64] = rand_normal_matrix((3,2))
    C: NDArray[Shape2D[TWO, TWO], np.float64] = dot(A, B)
    print(C)
  #+end_src

  #+RESULTS:
  : [[ 0.91270269  1.14463641]
  :  [-0.05479925  0.05966535]]

  And if we check with ~pyright~:

  #+HEADER: :results output
  #+begin_src bash :dir (org-sbe container-dir-str-shape-typing) :session pyright-shape-typing
    py -m pyright good_dot.py --lib
  #+end_src

  #+RESULTS:
  #+begin_example
  /opt/project/.venv/lib/python3.11/site-packages/nodeenv.py:26: DeprecationWarning: 'pipes' is deprecated and slated for removal in Python 3.13
    import pipes
   ,* Install prebuilt node (19.7.0) ..... done.
  No configuration file found.
  No pyproject.toml file found.
  stubPath /mnt/typings is not a valid directory.
  Assuming Python platform Linux
  Searching for source files
  Found 1 source file
  pyright 1.1.298
  0 errors, 0 warnings, 0 informations
  Completed in 0.546sec
  #+end_example

  Everything looks good as it should!

  And if we change the types to invalid matrix shapes:

  #+HEADER: :exports code :results output verbatim
  #+HEADER: :tangle bad_dot.py :noeval
  #+begin_src python
    import numpy as np
    from numpy.typing import NDArray
    from numpy_shape_typing.dot import dot
    from numpy_shape_typing.rand import rand_normal_matrix
    from numpy_shape_typing.types import ShapeNDType, Shape2D

    from typing import Literal

    TWO = Literal[2]
    THREE = Literal[3]
    FOUR = Literal[4]
    A: NDArray[Shape2D[TWO, THREE], np.float64] = rand_normal_matrix((2,3))
    B: NDArray[Shape2D[FOUR, FOUR], np.float64] = rand_normal_matrix((4,4))

    # uh oh bad shape type
    C: NDArray[Shape2D[TWO, TWO], np.float64] = dot(A, B)
    print(C)
  #+end_src

  #+RESULTS:

  And if we check with ~pyright~:

  #+HEADER: :results output
  #+begin_src bash :dir (org-sbe container-dir-str-shape-typing) :session pyright-bad-shape-typing
    py -m pyright ./bad_dot.py --lib
  #+end_src

  #+RESULTS:
  #+begin_example
  /opt/project/.venv/lib/python3.11/site-packages/nodeenv.py:26: DeprecationWarning: 'pipes' is deprecated and slated for removal in Python 3.13
    import pipes
   ,* Install prebuilt node (19.7.0) ..... done.
  No configuration file found.
  No pyproject.toml file found.
  stubPath /mnt/typings is not a valid directory.
  Assuming Python platform Linux
  Searching for source files
  Found 1 source file
  pyright 1.1.298
  /mnt/bad_dot.py
    /mnt/bad_dot.py:16:49 - error: Argument of type "NDArray[Shape2D[TWO, THREE], float64]" cannot be assigned to parameter "x1" of type "GenericDType@dot" in function "dot"
    Â Â Type "NDArray[Shape2D[TWO, THREE], float64]" cannot be assigned to type "NDArray[Shape2D[TWO, TWO], float64]"
    Â Â Â Â "NDArray[Shape2D[TWO, THREE], float64]" is incompatible with "NDArray[Shape2D[TWO, TWO], float64]"
    Â Â Â Â Â Â TypeVar "_ShapeType@ndarray" is invariant
    Â Â Â Â Â Â Â Â "*tuple[Shape2D[TWO, THREE]]" is incompatible with "*tuple[Shape2D[TWO, TWO]]"
    Â Â Â Â Â Â Â Â Â Â Tuple entry 1 is incorrect type (reportGeneralTypeIssues)
    /mnt/bad_dot.py:16:52 - error: Argument of type "NDArray[Shape2D[FOUR, FOUR], float64]" cannot be assigned to parameter "x2" of type "GenericDType@dot" in function "dot"
    Â Â Type "NDArray[Shape2D[FOUR, FOUR], float64]" cannot be assigned to type "NDArray[Shape2D[TWO, TWO], float64]"
    Â Â Â Â "NDArray[Shape2D[FOUR, FOUR], float64]" is incompatible with "NDArray[Shape2D[TWO, TWO], float64]"
    Â Â Â Â Â Â TypeVar "_ShapeType@ndarray" is invariant
    Â Â Â Â Â Â Â Â "*tuple[Shape2D[FOUR, FOUR]]" is incompatible with "*tuple[Shape2D[TWO, TWO]]"
    Â Â Â Â Â Â Â Â Â Â Tuple entry 1 is incorrect type (reportGeneralTypeIssues)
  2 errors, 0 warnings, 0 informations
  Completed in 0.547sec
  #+end_example

  ~pyright~ let's us know that the types we are using are incorrect shapes based
  on ~np.dot~'s type overloads we've specified.

* Even moar ~numpy~ shape typing!

  The next function we are going to type is ~np.add~. The [[https://numpy.org/doc/stable/reference/generated/numpy.add.html][~numpy~ docs]] only show
  two cases.

  1. Two ~ND~ array arguments of the same shape are added element wise

  2. Two ~ND~ array arguments that are not the same shape must be broadcastable to
     a common shape

  Covering the first case is easy, but the second case is much harder as we
  would have to come up with a scheme to cover ~numpy~'s [[https://numpy.org/doc/stable/user/basics.broadcasting.html][array broadcasting
  system]]. Currently ~python==3.11~'s ~typing~ doesn't have a generic way to
  cover all the broadcasting rules. (If you know of a way let me know!)

  However if we scope down the second case to only two dimensions, we can cover
  all the array broadcasting rules with a few overloads:

  #+HEADER: :exports code
  #+begin_src python :noeval
    from typing import overload

    import numpy as np
    from numpy.typing import NDArray

    from numpy_shape_typing.types import ONE, T1, T2, GenericDType, Shape1D, Shape2D, ShapeVarGen


    @overload
    def add(
        x1: NDArray[Shape2D[T1, T2], GenericDType],
        x2: NDArray[Shape1D[T2], GenericDType],
        /,
    ) -> NDArray[Shape2D[T1, T2], GenericDType]:
        ...


    @overload
    def add(
        x1: NDArray[Shape1D[T2], GenericDType],
        x2: NDArray[Shape2D[T1, T2], GenericDType],
        /,
    ) -> NDArray[Shape2D[T1, T2], GenericDType]:
        ...


    @overload
    def add(
        x1: NDArray[Shape2D[T1, T2], GenericDType],
        x2: NDArray[Shape1D[ONE], GenericDType],
        /,
    ) -> NDArray[Shape2D[T1, T2], GenericDType]:
        ...


    @overload
    def add(
        x1: NDArray[Shape1D[ONE], GenericDType],
        x2: NDArray[Shape2D[T1, T2], GenericDType],
        /,
    ) -> NDArray[Shape2D[T1, T2], GenericDType]:
        ...


    @overload
    def add(
        x1: NDArray[Shape2D[T1, T2], GenericDType],
        x2: NDArray[Shape2D[T1, ONE], GenericDType],
        /,
    ) -> NDArray[Shape2D[T1, T2], GenericDType]:
        ...


    @overload
    def add(
        x1: NDArray[Shape2D[T1, T2], GenericDType],
        x2: NDArray[Shape2D[ONE, T2], GenericDType],
        /,
    ) -> NDArray[Shape2D[T1, T2], GenericDType]:
        ...


    @overload
    def add(
        x1: NDArray[Shape2D[T1, ONE], GenericDType],
        x2: NDArray[Shape2D[T1, T2], GenericDType],
        /,
    ) -> NDArray[Shape2D[T1, T2], GenericDType]:
        ...


    @overload
    def add(
        x1: NDArray[Shape2D[ONE, T2], GenericDType],
        x2: NDArray[Shape2D[T1, T2], GenericDType],
        /,
    ) -> NDArray[Shape2D[T1, T2], GenericDType]:
        ...


    @overload
    def add(
        x1: GenericDType,
        x2: NDArray[Shape2D[T1, T2], GenericDType],
        /,
    ) -> NDArray[Shape2D[T1, T2], GenericDType]:
        ...


    @overload
    def add(
        x1: NDArray[Shape2D[T1, T2], GenericDType],
        x2: GenericDType,
        /,
    ) -> NDArray[Shape2D[T1, T2], GenericDType]:
        ...


    @overload
    def add(
        x1: NDArray[*ShapeVarGen, GenericDType],
        x2: NDArray[*ShapeVarGen, GenericDType],
        /,
    ) -> NDArray[*ShapeVarGen, GenericDType]:
        ...


    def add(x1, x2):
        return np.add(x1, x2)
  #+end_src

  Using these overloads, here is how we would catch unexpected array broadcasts
  (similar to the one from our original ~Linear~ example).

  #+HEADER: :exports code :results output verbatim
  #+HEADER: :tangle unnexpected_broadcast.py
  #+begin_src python :dir (org-sbe container-dir-str-shape-typing)
    from typing import Literal

    import numpy as np
    from numpy.typing import NDArray

    from numpy_shape_typing.add import add
    from numpy_shape_typing.dot import dot
    from numpy_shape_typing.rand import rand_normal_matrix
    from numpy_shape_typing.types import ONE, Shape1D, Shape2D

    FOUR = Literal[4]
    A: NDArray[Shape2D[FOUR, FOUR], np.float64] = rand_normal_matrix((4, 4))
    B: NDArray[Shape2D[ONE, FOUR], np.float64] = rand_normal_matrix((1, 4))
    C: NDArray[Shape2D[ONE, FOUR], np.float64] = add(A, B)
    print(C)
  #+end_src

  #+RESULTS:
  : [[ 0.52190456 -0.59038544 -0.16410868 -1.97714141]
  :  [-1.36188878 -1.32828576 -0.0162497   1.1594779 ]
  :  [-0.85793515 -0.47610803 -1.03530451 -1.07469943]
  :  [ 2.29569189  1.48435967  0.54641844 -0.42001828]]

  In the example above, our output is a ~4x4~ matrix, but from our types we wanted
  an output shape of ~4x1~. Let's see what ~pyright~ says

  #+HEADER: :results output
  #+begin_src bash :dir (org-sbe container-dir-str-shape-typing) :session pyright-bad-shape-typing
    py -m pyright unnexpected_broadcast.py --lib
  #+end_src

  #+RESULTS:
  #+begin_example
  /opt/project/.venv/lib/python3.11/site-packages/nodeenv.py:26: DeprecationWarning: 'pipes' is deprecated and slated for removal in Python 3.13
    import pipes
   ,* Install prebuilt node (19.7.0) ..... done.
  No configuration file found.
  No pyproject.toml file found.
  stubPath /mnt/typings is not a valid directory.
  Assuming Python platform Linux
  Searching for source files
  Found 1 source file
  pyright 1.1.298
  /mnt/unnexpected_broadcast.py
    /mnt/unnexpected_broadcast.py:14:50 - error: Argument of type "NDArray[Shape2D[FOUR, FOUR], float64]" cannot be assigned to parameter "x1" of type "NDArray[*ShapeVarGen@add, GenericDType@add]" in function "add"
    Â Â "NDArray[Shape2D[FOUR, FOUR], float64]" is incompatible with "NDArray[Shape2D[ONE, FOUR], float64]"
    Â Â Â Â TypeVar "_ShapeType@ndarray" is invariant
    Â Â Â Â Â Â "*tuple[Shape2D[FOUR, FOUR]]" is incompatible with "*tuple[Shape2D[ONE, FOUR]]"
    Â Â Â Â Â Â Â Â Tuple entry 1 is incorrect type
    Â Â Â Â Â Â Â Â Â Â "Shape2D[FOUR, FOUR]" is incompatible with "Shape2D[ONE, FOUR]" (reportGeneralTypeIssues)
  1 error, 0 warnings, 0 informations
  Completed in 0.578sec
  #+end_example




* Hitting the limitations of shape typing ðŸ˜¿

  The last function we will type to finish of our ~Linear~ example is
  ~np.ravel~. However this is where we start hitting some major limitations of
  shape typing as they exist today in ~python~ and ~numpy~.

  From the [[https://numpy.org/doc/stable/reference/generated/numpy.ravel.html][numpy docs on]] ~np.ravel~ the only case we need to cover is that any
  ~ND~ array gets collapsed into a ~1D~ array of size of the total number of
  elements. Luckily all the information to compute the final ~1D~ size is just
  the product of all the input dimension sizes.

  Ideally we would try to write code that looks something like this:

  #+HEADER: :exports code
  #+begin_src python :noeval
    ShapeVarGen = TypeVarTuple("ShapeVarGen")

    @overload
    def ravel(
        arr: NDArray[Shape[*ShapeVarGen], GenericDType]
    ) -> NDArray[Shape1D[Product[*ShapeVarGen]], GenericDType]:
        ...
  #+end_src

  But unfortunately ~python~'s ~typing~ package currently doesn't have a notion
  of a ~Product~ type that provides a way to do algebraic typing.

  However for the sake of completion we can fake it!

  If we scope down from a generic ~ND~ typing of ~np.ravel~ to support up to two
  dimensions and limit the size of the output dimension to some maximum number,
  we can overload all the possible factors that multiply to the output dimension
  size. We would effectively be typing a multiplication table ðŸ˜†, but it will
  work and get us to a "partially" typed ~np.ravel~.

  Here's how we can do it.

  First we create a bunch of ~Literal~ types (our factors):

  #+HEADER: :exports code
  #+begin_src python :noeval
    ZERO = Literal[0]
    ONE = Literal[1]
    TWO = Literal[2]
    THREE = Literal[3]
    FOUR = Literal[4]
    ...
  #+end_src

  Then we define "multiply" types for factor pairs of numbers:

  #+HEADER: :exports code
  #+begin_src python :noeval
    SHAPE_2D_MUL_TO_ONE = TypeVar(
        "SHAPE_2D_MUL_TO_ONE",
        bound=Shape2D[Literal[ONE], Literal[ONE]],
    )
    SHAPE_2D_MUL_TO_TWO = TypeVar(
        "SHAPE_2D_MUL_TO_TWO",
        bound=Union[Shape2D[Literal[ONE], Literal[TWO]], Shape2D[Literal[TWO], Literal[ONE]]],
    )
    SHAPE_2D_MUL_TO_THREE = TypeVar(
        "SHAPE_2D_MUL_TO_THREE",
        bound=Union[Shape2D[Literal[ONE], Literal[THREE]], Shape2D[Literal[THREE], Literal[ONE]]],
    )
    SHAPE_2D_MUL_TO_FOUR = TypeVar(
        "SHAPE_2D_MUL_TO_FOUR",
        bound=Union[
            Shape2D[Literal[ONE], Literal[FOUR]],
            Shape2D[Literal[TWO], Literal[TWO]],
            Shape2D[Literal[FOUR], Literal[ONE]],
        ],
    )
  #+end_src

  Then lastly we wire these types up into individual ~ravel~ overloads (and
  cover a few generic ones while we're at it):

  #+HEADER: :exports code
  #+begin_src python :noeval
    @overload
    def ravel(arr: NDArray[SHAPE_2D_MUL_TO_ONE, GenericDType]) -> NDArray[Shape1D[ONE], GenericDType]:
        ...


    @overload
    def ravel(arr: NDArray[SHAPE_2D_MUL_TO_TWO, GenericDType]) -> NDArray[Shape1D[TWO], GenericDType]:
        ...


    @overload
    def ravel(arr: NDArray[SHAPE_2D_MUL_TO_THREE, GenericDType]) -> NDArray[Shape1D[THREE], GenericDType]:
        ...


    @overload
    def ravel(arr: NDArray[SHAPE_2D_MUL_TO_FOUR, GenericDType]) -> NDArray[Shape1D[FOUR], GenericDType]:
        ...

    @overload
    def ravel(arr: NDArray[Shape2D[T1, ONE], GenericDType]) -> NDArray[Shape1D[T1], GenericDType]:
        ...


    @overload
    def ravel(arr: NDArray[Shape2D[ONE, T1], GenericDType]) -> NDArray[Shape1D[T1], GenericDType]:
        ...


    @overload
    def ravel(arr: NDArray[Shape1D[T1], GenericDType]) -> NDArray[Shape1D[T1], GenericDType]:
        ...
  #+end_src

  Now we can rinse and repeat for as many numbers as we like!

  Here is how we'd use this typing to catch a shape type error with ~ravel~:

  #+HEADER: :exports code :results output verbatim
  #+HEADER: :tangle raveling.py :noeval
  #+begin_src python
    import numpy as np
    from numpy.typing import NDArray

    from numpy_shape_typing.rand import rand_normal_matrix
    from numpy_shape_typing.ravel import ravel
    from numpy_shape_typing.types import FOUR, SEVEN, TWO, Shape1D, Shape2D

    A: NDArray[Shape2D[TWO, FOUR], np.float64] = rand_normal_matrix((2, 4))
    B: NDArray[Shape1D[SEVEN], np.float64] = ravel(A)
    print(B)
  #+end_src

  #+RESULTS:

  #+HEADER: :results output
  #+begin_src bash :dir (org-sbe container-dir-str-shape-typing) :session pyright-bad-shape-typing
    py -m pyright raveling.py --lib
  #+end_src

  #+RESULTS:
  #+begin_example
  /opt/project/.venv/lib/python3.11/site-packages/nodeenv.py:26: DeprecationWarning: 'pipes' is deprecated and slated for removal in Python 3.13
    import pipes
   ,* Install prebuilt node (19.7.0) ..... done.
  No configuration file found.
  No pyproject.toml file found.
  stubPath /mnt/typings is not a valid directory.
  Assuming Python platform Linux
  Searching for source files
  Found 1 source file
  pyright 1.1.298
  /mnt/raveling.py
    /mnt/raveling.py:9:42 - error: Expression of type "NDArray[Shape1D[EIGHT], float64]" cannot be assigned to declared type "NDArray[Shape1D[SEVEN], float64]"
    Â Â "NDArray[Shape1D[EIGHT], float64]" is incompatible with "NDArray[Shape1D[SEVEN], float64]"
    Â Â Â Â TypeVar "_ShapeType@ndarray" is invariant
    Â Â Â Â Â Â "*tuple[Shape1D[EIGHT]]" is incompatible with "*tuple[Shape1D[SEVEN]]"
    Â Â Â Â Â Â Â Â Tuple entry 1 is incorrect type
    Â Â Â Â Â Â Â Â Â Â "Shape1D[EIGHT]" is incompatible with "Shape1D[SEVEN]" (reportGeneralTypeIssues)
  1 error, 0 warnings, 0 informations
  Completed in 0.558sec
  #+end_example

* Putting it all together

  So far we've gone through typing a small subset of ~numpy~'s functions
  (~np.random.standard_normal~, ~np.dot~, ~np.add~, and ~np.ravel~ in all).

  Now we can chain these typed functions together to form a typed ~Linear~
  implementation like so:

  #+HEADER: :exports code :results output verbatim
  #+HEADER: :tangle linear_type_bad.py :noeval
  #+begin_src python
    from typing import Literal

    import numpy as np
    from numpy.typing import NDArray

    from numpy_shape_typing.add import add
    from numpy_shape_typing.dot import dot
    from numpy_shape_typing.rand import rand_normal_matrix
    from numpy_shape_typing.ravel import ravel
    from numpy_shape_typing.types import ONE, T1, T2, GenericDType, Shape1D, Shape2D


    def Linear(
            A: NDArray[Shape2D[T1, T2], GenericDType],
            x: NDArray[Shape2D[T2, ONE], GenericDType],
            b: NDArray[Shape2D[T1, ONE], GenericDType],
    ) -> NDArray[Shape1D[T1], GenericDType]:
        Ax = dot(A, x)
        Axb = add(Ax, b)
        return ravel(Axb)


    IN_DIM = Literal[3]
    in_dim: IN_DIM = 3

    OUT_DIM = Literal[4]
    out_dim: OUT_DIM = 4

    # bad type >:(
    BAD_OUT_DIM = Literal[5]

    A: NDArray[Shape2D[OUT_DIM, IN_DIM], np.float64] = rand_normal_matrix((out_dim, in_dim))
    x: NDArray[Shape2D[IN_DIM, ONE], np.float64] = rand_normal_matrix((in_dim, 1))
    b: NDArray[Shape2D[OUT_DIM, ONE], np.float64] = rand_normal_matrix((out_dim, 1))

    # this is a bad type! we should have an output shape type of "Shape1D[BAD_OUT_DIM]"
    y: NDArray[Shape1D[BAD_OUT_DIM], np.float64] = Linear(A, x, b)
  #+end_src

  #+RESULTS:

  I've included an intentional type error which should be caught by ~pyright~
  like so:

  #+HEADER: :results output
  #+begin_src bash :dir (org-sbe container-dir-str-shape-typing) :session pyright-bad-shape-typing
    py -m pyright linear_type_bad.py --lib
  #+end_src

  #+RESULTS:
  #+begin_example
  /opt/project/.venv/lib/python3.11/site-packages/nodeenv.py:26: DeprecationWarning: 'pipes' is deprecated and slated for removal in Python 3.13
    import pipes
   ,* Install prebuilt node (19.7.0) ..... done.
  No configuration file found.
  No pyproject.toml file found.
  stubPath /mnt/typings is not a valid directory.
  Assuming Python platform Linux
  Searching for source files
  Found 1 source file
  pyright 1.1.298
  /mnt/linear_type_bad.py
    /mnt/linear_type_bad.py:37:55 - error: Argument of type "NDArray[Shape2D[OUT_DIM, IN_DIM], float64]" cannot be assigned to parameter "A" of type "NDArray[Shape2D[T1@Linear, T2@Linear], GenericDType@Linear]" in function "Linear"
    Â Â "NDArray[Shape2D[OUT_DIM, IN_DIM], float64]" is incompatible with "NDArray[Shape2D[BAD_OUT_DIM, IN_DIM], float64]"
    Â Â Â Â TypeVar "_ShapeType@ndarray" is invariant
    Â Â Â Â Â Â "*tuple[Shape2D[OUT_DIM, IN_DIM]]" is incompatible with "*tuple[Shape2D[BAD_OUT_DIM, IN_DIM]]"
    Â Â Â Â Â Â Â Â Tuple entry 1 is incorrect type
    Â Â Â Â Â Â Â Â Â Â "Shape2D[OUT_DIM, IN_DIM]" is incompatible with "Shape2D[BAD_OUT_DIM, IN_DIM]" (reportGeneralTypeIssues)
    /mnt/linear_type_bad.py:37:61 - error: Argument of type "NDArray[Shape2D[OUT_DIM, ONE], float64]" cannot be assigned to parameter "b" of type "NDArray[Shape2D[T1@Linear, ONE], GenericDType@Linear]" in function "Linear"
    Â Â "NDArray[Shape2D[OUT_DIM, ONE], float64]" is incompatible with "NDArray[Shape2D[BAD_OUT_DIM, ONE], float64]"
    Â Â Â Â TypeVar "_ShapeType@ndarray" is invariant
    Â Â Â Â Â Â "*tuple[Shape2D[OUT_DIM, ONE]]" is incompatible with "*tuple[Shape2D[BAD_OUT_DIM, ONE]]"
    Â Â Â Â Â Â Â Â Tuple entry 1 is incorrect type
    Â Â Â Â Â Â Â Â Â Â "Shape2D[OUT_DIM, ONE]" is incompatible with "Shape2D[BAD_OUT_DIM, ONE]" (reportGeneralTypeIssues)
  2 errors, 0 warnings, 0 informations
  Completed in 0.657sec
  #+end_example

  And huzzah again! ~pyright~ has caught the shape type error!

  And now we can fix this shape error by changing ~BAD_OUT_DIM~ to the correct
  output dimension size.

  #+HEADER: :exports code :results output verbatim
  #+HEADER: :tangle linear_type_good.py :noeval
  #+begin_src python
    from typing import Literal

    import numpy as np
    from numpy.typing import NDArray

    from numpy_shape_typing.add import add
    from numpy_shape_typing.dot import dot
    from numpy_shape_typing.rand import rand_normal_matrix
    from numpy_shape_typing.ravel import ravel
    from numpy_shape_typing.types import ONE, T1, T2, GenericDType, Shape1D, Shape2D


    def Linear(
            A: NDArray[Shape2D[T1, T2], GenericDType],
            x: NDArray[Shape2D[T2, ONE], GenericDType],
            b: NDArray[Shape2D[T1, ONE], GenericDType],
    ) -> NDArray[Shape1D[T1], GenericDType]:
        Ax = dot(A, x)
        Axb = add(Ax, b)
        return ravel(Axb)


    IN_DIM = Literal[3]
    in_dim: IN_DIM = 3

    OUT_DIM = Literal[4]
    out_dim: OUT_DIM = 4

    A: NDArray[Shape2D[OUT_DIM, IN_DIM], np.float64] = rand_normal_matrix((out_dim, in_dim))
    x: NDArray[Shape2D[IN_DIM, ONE], np.float64] = rand_normal_matrix((in_dim, 1))
    b: NDArray[Shape2D[OUT_DIM, ONE], np.float64] = rand_normal_matrix((out_dim, 1))
    y: NDArray[Shape1D[OUT_DIM], np.float64] = Linear(A, x, b)
  #+end_src

  #+RESULTS:

  And if we check with ~pyright~.

  #+HEADER: :results output
  #+begin_src bash :dir (org-sbe container-dir-str-shape-typing) :session pyright-bad-shape-typing
    py -m pyright linear_type_good.py --lib
  #+end_src

  #+RESULTS:
  #+begin_example
  /opt/project/.venv/lib/python3.11/site-packages/nodeenv.py:26: DeprecationWarning: 'pipes' is deprecated and slated for removal in Python 3.13
    import pipes
   ,* Install prebuilt node (19.7.0) ..... done.
  No configuration file found.
  No pyproject.toml file found.
  stubPath /mnt/typings is not a valid directory.
  Assuming Python platform Linux
  Searching for source files
  Found 1 source file
  pyright 1.1.298
  0 errors, 0 warnings, 0 informations
  Completed in 0.647sec
  #+end_example

  ~pyright~ tells us that our types are consistent!
