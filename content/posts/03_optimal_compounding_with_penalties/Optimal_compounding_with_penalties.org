#+TITLE: Optimal compounding with penalties
#+CREATED: [2021-08-11 Wed 00:48]
#+LAST_MODIFIED: [2021-09-17 Fri 13:33]
#+ROAM_TAGS: money composition
#+STARTUP: showall indent
#+OPTIONS: toc:nil
#+OPTIONS: tex:t
#+OPTIONS: ^:nil p:nil

#+HUGO_BASE_DIR: ./
#+hugo_front_matter_format: yaml
#+HUGO_CUSTOM_FRONT_MATTER: :date (org-to-blog-date (org-global-prop-value "CREATED"))
#+HUGO_CUSTOM_FRONT_MATTER: :hero ./images/hero.jpg
#+HUGO_CUSTOM_FRONT_MATTER: :secret false
#+HUGO_CUSTOM_FRONT_MATTER: :excerpt Making money with your money's money

* Forward for the author                                           :noexport:

This post has a heavy focus on technical literate programming. This documents
goal is too produce two products. One for the author/developer and one for the
reader. The author's version gets to view the document in full, while the
reader's view is only the exported version. The explicit pieces that not
exported (and therefore hidden from the reader's view) are those which are not
directly relevant to the content of the article. This includes tools for the
author, exporting functionality, tests, configuration, etc.

** Exporting

#+BEGIN_SRC emacs-lisp :exports none
  ;; All inline code blocks will be latex
  (setq org-babel-inline-result-wrap "$%s$")

  ;; Configure languages
  (org-babel-do-load-languages
   'org-babel-load-languages
   '((shell . t)
     (python . t)))

  ;; Setup org/latex exporting
  (add-to-list 'org-export-filter-latex-fragment-functions
               'sub-paren-for-dollar-sign)
  (add-to-list 'org-export-filter-headline-functions
               'remove-regexp-curly-braces)
  (add-to-list 'org-export-filter-latex-environment-functions
               'sub-paren-for-dollar-sign)
  (export-to-mdx-on-save)
#+END_SRC

#+RESULTS:
: Enabled mdx on save

** Configuration

The primary language we will be using is python inside of a container, org mode
(with TRAMP) has the fantastic feature of being able to execute src code blocks
inside a container which we will be leveraging for this post to the purpose of
isolation.

#+CONSTANTS: container_name=compounder

#+NAME: container-dir-str
#+HEADER: :exports none
#+begin_src emacs-lisp
  (setq shutdown-env nil)
  (setq docker-tramp-docker-executable "podman")
  (docker-tramp-add-method)
  (setq ob-ipython-command "ipython")
  (setq org-babel-python-command "ipython")
  (setq py-default-interpreter "ipython")
  (setq container-dir-str (format "/docker:sage@%s:/mnt" (org-table-get-constant "container_name")))
#+end_src

#+RESULTS: container-dir-str
: /docker:sage@compounder:/mnt

** Environment setup

As mentioned we will be running the following code inside a container. Here we
setup our base container as sagemath, install some necessary package, and a
interactive python session with the starting variables

#+HEADER: :exports none
#+begin_src bash :results verbatim :var NAME=(org-table-get-constant "container_name")
  echo "Pulling image ..."
  podman pull docker.io/sagemath/sagemath:latest

  echo "Running container if not already running ..."
  [ ! "$(podman ps | grep $NAME)" ] && \
    podman run \
           -d \
           -u $(id -u):$(id -g) \
           --userns keep-id \
           --name $NAME \
           --rm \
           -v $(pwd):/mnt \
           -w /mnt \
           -it sagemath/sagemath:latest; \
    echo "Container starting..." \
    || \
    echo "Container already running..."
#+end_src

#+RESULTS:
: Pulling image ...
: b08484514181283508800a0d573948f6e1f50b32cc2f0ebb765d428f511d4017
: Running container if not already running ...
: 52a4c7d619062f72088203e5586233d2924847f94e95b1a9cd4366520cface5b
: Container starting...

#+HEADER: :exports none
#+HEADER: :dir (org-sbe container-dir-str)
#+begin_src sh
  sage -python -m pip install plotly kaleido -q
  echo "$(date): Done!"
#+end_src

#+RESULTS:
: Fri Sep 17 03:24:43 UTC 2021: Done!

#+BEGIN_SRC python :exports none :results output :dir (org-sbe container-dir-str) :session
  import sympy
  from sage.all import *
  from sage.plot.plot3d.plot3d import axes
  from sage.numerical.optimize import minimize
  from sage.manifolds.utilities import set_axes_labels

  latex_center = lambda expr: \
    '\n' + \
    LatexExpr("\\begin{alignedat}{2}") + \
    '\n' + \
    expr + \
    '\n' + \
    LatexExpr("\\end{alignedat}") + \
    '\n'

  latex_right = lambda a, b: \
    a + LatexExpr(" \\rightarrow ") + b

  latex_lim = lambda expr, a, b: \
    LatexExpr("\\lim\\limits_{") + \
    a + \
    LatexExpr("\\rightarrow") + \
    b + \
    LatexExpr("}") + \
    expr

  print("imported")
#+END_SRC

#+RESULTS:
: imported

#+HEADER: :exports none :results output :session
#+HEADER: :dir (org-sbe container-dir-str)
#+BEGIN_SRC python
  n = var('n')

  P, f, r, i = var("P f r i")
  assume(P > 0)
  assume(f > 0)
  assume(r > 0)
  print("Variables created")
#+END_SRC

#+RESULTS:
: Variables created

* Cryptocurrency dividends? ðŸ¤”

Most people who are "in the know" of the cryptocurrency world have probobaly
heard of the various ways to make a return from their tokens. People can deposit
their tokens via staking, lending, or Liquidity Pools and sit back to earn
additional tokens, increasing their portfolios value. This is starkly different
from the norm which is HODLing tokens and waiting for their prices to increase.

If these earners continually invest their returns back into these earning
protocols, they benefit from the :sparkles:magic:sparkles: that is compound
interest. Unfortunately most cryptocurrency/blockchain projects are pay to play,
meaning that if you want to interact with any of these earning protocols, you
need to spend tokens to make tokens. This begs the question: what's the most
efficent way to spend the least amount of tokens too make the most returns?

* DONE Abstracting the earning process
CLOSED: [2021-09-17 Fri 13:10]

There are many methods to earn "dividends" from cryptocurrency. However most
earning protocols expose the same metrics which we will use to our advantage. To
start, we will lay out the following paramaters for the earning process:

- src_python[:results output :session :dir (org-sbe container-dir-str)]{print(latex(n))} - Number of compounds per year
- src_python[:results output :session :dir (org-sbe container-dir-str)]{print(latex(P))} - Initial balance
- src_python[:results output :session :dir (org-sbe container-dir-str)]{print(latex(r))} - APY
- src_python[:results output :session :dir (org-sbe container-dir-str)]{print(latex(f))} - Fee per compound

The following paramaters give us the foundation of compound interest.

#+NAME: compound-interest
#+HEADER: :exports none :results output :session
#+HEADER: :dir (org-sbe container-dir-str)
#+BEGIN_SRC python
  compound_interest = ( P * ( 1 + ( r / n ) ) ** n )
  compound_interest_latex = latex_center(latex(compound_interest))
  print(compound_interest_latex)
#+END_SRC

#+RESULTS: compound-interest
:
:  \begin{alignedat}{2}
:  P {\left(\frac{r}{n} + 1\right)}^{n}
:  \end{alignedat}

#+MACRO: compound-interest (eval (latex-display-wrap (org-sbe compound-interest)))

{{{compound-interest()}}}

While this is all well and good, we want to account for the fact that whenever
we want to "compound" our pending earnings, we need pay a fee to do so. With
this in mind we need to come up with an expression to account for each
penalization fee src_python[:results output :session :dir (org-sbe
container-dir-str)]{print(latex(f))} over each compounding instance
src_python[:results output :session :dir (org-sbe
container-dir-str)]{print(latex(n))}.

To do this we will add on the idea of iterative penalties which is the summation
of fees across every compounding instance.

#+NAME: iterative-penalty
#+HEADER: :exports none :results output :session
#+HEADER: :dir (org-sbe container-dir-str)
#+BEGIN_SRC python
iterative_penalty = ( f * sum( (1 + (r / n))**i , i, 0, n-1, hold=True) )
print(latex_center(latex(iterative_penalty)))
#+END_SRC

#+RESULTS: iterative-penalty
:
:  \begin{alignedat}{2}
:  f {\sum_{i=0}^{n - 1} {\left(\frac{r}{n} + 1\right)}^{i}}
:  \end{alignedat}

#+MACRO: iterative-penalty (eval (latex-display-wrap (org-sbe iterative-penalty)))

{{{iterative-penalty()}}}

By subtracting the two ideas we can get the expression

#+NAME: compound-interest-with-iterative-penalty-verbose
#+HEADER: :exports none :results output :session
#+HEADER: :dir (org-sbe container-dir-str)
#+BEGIN_SRC python
  compound_interest_with_iterative_penalty = compound_interest - iterative_penalty
  print(latex_center(latex(compound_interest_with_iterative_penalty)))
#+END_SRC

#+RESULTS: compound-interest-with-iterative-penalty-verbose
:
:  \begin{alignedat}{2}
:  P {\left(\frac{r}{n} + 1\right)}^{n} - f {\sum_{i=0}^{n - 1} {\left(\frac{r}{n} + 1\right)}^{i}}
:  \end{alignedat}

#+MACRO: compound-interest-with-iterative-penalty-verbose (eval (latex-display-wrap (org-sbe compound-interest-with-iterative-penalty-verbose)))

{{{compound-interest-with-iterative-penalty-verbose()}}}

Simplifying we can get the function

#+NAME: compound-interest-with-iterative-penalty-simple
#+HEADER: :exports none :results output :session
#+HEADER: :dir (org-sbe container-dir-str)
#+BEGIN_SRC python
  compound_interest_with_iterative_penalty = compound_interest - iterative_penalty.unhold()
  ciwip, c = function('ciwip'), function('c')
  print(latex_center(latex(ciwip(P,f,r,n) == compound_interest - iterative_penalty.unhold())))
#+END_SRC

#+RESULTS: compound-interest-with-iterative-penalty-simple
:
:  \begin{alignedat}{2}
:  {\rm ciwip}\left(P, f, r, n\right) = P {\left(\frac{r}{n} + 1\right)}^{n} - \frac{{\left(n \left(\frac{n + r}{n}\right)^{n} - n\right)} f}{r}
:  \end{alignedat}

#+MACRO: compound-interest-with-iterative-penalty-simple (eval (latex-display-wrap (org-sbe compound-interest-with-iterative-penalty-simple)))

{{{compound-interest-with-iterative-penalty-simple()}}}

Now lets pause and try to intuitively think about this expression and what it
means. If we compound src_python[:results output :session :dir (org-sbe
container-dir-str)]{print(latex_right(latex(n), latex(oo)))} we will end up with
a src_python[:results output :session :dir (org-sbe
container-dir-str)]{print(latex(oo))} amount of money due to the right hand
component blowing up. This also makes sense as we will be paying the fee an
infinite amount of times. If we compound at least 1 time (since
src_python[:results output :session :dir (org-sbe
container-dir-str)]{print(latex(n == 0))} is undefined), it is not hard to see
how under the right circumstances we could have increased src_python[:results
output :session :dir (org-sbe container-dir-str)]{print(latex(n))} such that we
could have earned more. This is a poor explanation and there is a better proof
to describe this but take my word that under the right circumstances there is an
optimum from compounding between 1 and infinity. To understand where this
maximum is we need to understand this function a little deeper.

To learn a little more about the 'shape' of this function, lets unify all the
paramaters we can't 'control' under some var src_python[:results output :session
:dir (org-sbe container-dir-str)]{print(latex(C))} and plot what we have left in
3D.

#+NAME: homogenized-compound-interest-with-iterative-penalty
#+HEADER: :exports none :results output :session
#+HEADER: :dir (org-sbe container-dir-str)
#+BEGIN_SRC python
  C = var('C')
  homogenized_compound_interest_with_iterative_penalty = compound_interest_with_iterative_penalty.substitute(P=C, f=C, r=C)
  const_sympy = homogenized_compound_interest_with_iterative_penalty._sympy_()
  const_sympy_vars = {str(i): i for i in const_sympy.free_symbols}
  print(latex_center(latex(homogenized_compound_interest_with_iterative_penalty)))
#+END_SRC

#+RESULTS: homogenized-compound-interest-with-iterative-penalty
:
:  \begin{alignedat}{2}
:  -n \left(\frac{C + n}{n}\right)^{n} + C {\left(\frac{C}{n} + 1\right)}^{n} + n
:  \end{alignedat}

#+MACRO: homogenized-compound-interest-with-iterative-penalty (eval (latex-display-wrap (org-sbe homogenized-compound-interest-with-iterative-penalty)))

{{{homogenized-compound-interest-with-iterative-penalty()}}}

#+HEADER: :exports none :results output :session
#+HEADER: :dir (org-sbe container-dir-str)
#+begin_src python
  import numpy as np
  import plotly.graph_objects as go
  from plotly.subplots import make_subplots

  def get_plane(M, v, xx, yy, zz):

      # M point contained by the plane
      # v direction included in plane (orthogonal to w=[0, 0, 1])
      x0, y0, _= M
      a, b, _= v

      if a == 0 and b != 0:
          Y, Z = np.meshgrid(yy, zz)
          X = x0*np.ones(Y.shape)
      elif a != 0 and b==0:
          X, Z = np.meshgrid(xx, zz)
          Y = y0*np.ones(X.shape)
      else:
          X, Z = np.meshgrid(xx, zz)
          Y = y0+b*(X-x0)/a
      return X, Y, Z


  # define xy mesh and z func output
  xx = np.linspace(2, 12, 50)
  yy = np.linspace(2, 12, 50)
  x,y = np.meshgrid(xx, yy)
  fff = sympy.lambdify((const_sympy_vars["n"], const_sympy_vars["C"]), const_sympy, "numpy")
  z = fff(x, y)
  zz = np.linspace(z.min(), z.max(), 50)

  M = [0, 11, 0]  # a point in the plane
  v = [1, 0, 0] # a direction contained in the plane
  X, Y, Z =  get_plane(M, v, xx, yy, zz)

  fig = make_subplots(
       rows=1, cols=1,
       horizontal_spacing=0.1)
  fig.add_trace(go.Surface(x=x,
                           y=y,
                           z=z,
                           colorscale="Viridis",
                           lighting=dict(diffuse=0.9),
                           showscale=False))
  fig.add_trace(go.Surface(x=X, y=Y, z=Z,
                           colorscale= [[0, "rgb(254, 254, 254)"],
                                        [1, "rgb(254, 254, 254)"]],
                           showscale=False,
                           lighting=dict(diffuse=0.9),
                           opacity=0.3))
  fig.update_layout(
      scene_camera=dict(
        eye=dict(x=2, y=2.5, z=2.3)
      ),
      margin=dict(t=0, r=0, l=0, b=0),
      width=600, height=600, yaxis = {"domain":  [0, 0.85]},
      scene = dict(
                    xaxis_title='n',
                    yaxis_title='C',
                    zaxis_title='$')
  )
  fig.update_xaxes(autorange="reversed")
  fig.update_xaxes(range=[12, 1])
  fig.update_scenes(xaxis_autorange="reversed")
  fig.update_scenes(yaxis_autorange="reversed")
  fig.write_image("/mnt/homogenized-compound-interest-with-iterative-penalty.png")
  print("done!")
#+end_src

#+RESULTS:
: done!

#+CAPTION: A surface 3d plot of constant compound interest with iterative penalties
[[./homogenized-compound-interest-with-iterative-penalty.png]]

The interesting thing we can see here is that if we hold the variables we can't
control constant and slice the space with a plane (shown by the slightly opaque
vertical plane) we see that there is an optimal number of compounds that gives
us the highest yield. And if we minimize this function we can get our optimal
number of compounds

#+HEADER: :exports none :results output :session
#+HEADER: :dir (org-sbe container-dir-str)
#+begin_src python
  def optimal_compound_interest_with_iterative_penalty(P_, f_, r_):

      ## Formula for ciwip
      n = var('n')
      P, f, r, i = var("P f r i")
      #assume(P > 0)
      #assume(f > 0)
      #assume(r >= 0)
      compound_interest = ( P * ( 1 + ( r / n ) ) ** n )
      iterative_penalty = ( f * sum( (1 + (r / n))**i , i, 0, n-1) )
      compound_interest_with_iterative_penalty = compound_interest - iterative_penalty

      ## Compute ciwip from params and minimize
      ciwip_min_ = -1.0 * compound_interest_with_iterative_penalty.substitute(P=P_, f=f_, r=r_)
      ciwip_min_result = sage.numerical.optimize.minimize(
          ciwip_min_,
          [1e-10],
          algorithm='bfgs',
          gradient=ciwip_min_.diff()
      )
      print(ciwip_min_result)
      if compound_interest_with_iterative_penalty.substitute(P=P_, f=f_, r=r_, n=floor(ciwip_min_result[0])) > \
         compound_interest_with_iterative_penalty.substitute(P=P_, f=f_, r=r_, n=ceil(ciwip_min_result[0])):
          return floor(ciwip_min_result[0])
      else:
          return ceil(ciwip_min_result[0])
#+end_src

#+RESULTS:

If we look at the opaque plane cross section we see that it forms something that
looks convex. This means that we will be able to find an optimal number of
compounds to give us an optimal reward. Here is what the opaque plane looks like
graphed

#+NAME: tmp
#+HEADER: :exports none :results output :session
#+HEADER: :dir (org-sbe container-dir-str)
#+BEGIN_SRC python
  filename = '/mnt/f.png'
  n = var('n')
  P, f, r, i = var("P f r i")
  compound_interest = ( P * ( 1 + ( r / n ) ) ** n )
  iterative_penalty = ( f * sum( (1 + (r / n))**i , i, 0, n-1) )
  compound_interest_with_iterative_penalty = compound_interest - iterative_penalty
  s = {
      f: 3,
      r: 1,
      P: 70
  }
  g = Graphics()
  g += plot(compound_interest_with_iterative_penalty.subs(s), (0, 60))
  g.save(filename=filename)
  print(f"Filename: {filename}")
#+END_SRC

#+RESULTS: tmp
: Filename: /mnt/f.png

#+CAPTION: 2D view of compound interest with iterative penalties
[[./f.png]]

Something interesting to note is that if we can perform a bit of limit analysis
on the derivative of this function, we can see that the slope of this function
reaches a constant value.

#+NAME: compound-interest-with-iterative-penalty-diff-limit-analysis
#+HEADER: :exports none :results output :session
#+HEADER: :dir (org-sbe container-dir-str)
#+BEGIN_SRC python
  print(
      latex_center(
          latex_lim(
              latex(
                  ciwip(P,f,r,n).derivative(n) == \
                  limit(compound_interest_with_iterative_penalty.diff(n),n=oo)
              ),
              latex(n),
              latex(oo)
          )
      )
  )
#+END_SRC

#+RESULTS: compound-interest-with-iterative-penalty-diff-limit-analysis
:
:  \begin{alignedat}{2}
:  \lim\limits_{ n \rightarrow +\infty } \frac{\partial}{\partial n}{\rm ciwip}\left(P, f, r, n\right) = -\frac{f e^{r} - f}{r}
:  \end{alignedat}

#+MACRO: compound-interest-with-iterative-penalty-diff-limit-analysis (eval (latex-display-wrap (org-sbe compound-interest-with-iterative-penalty-diff-limit-analysis)))

{{{compound-interest-with-iterative-penalty-diff-limit-analysis()}}}

In order to find out if this function is truley convex, we can leverage Jensen's
inequality to check if the inequality is true.

$$
\begin{CD}
  g( \alpha x + ( 1 - \alpha ) y ) \geq \alpha g( x ) + ( 1 - \alpha ) g( y )
\end{CD}
$$

With this inequality we can plug in our function $c$ and check this inequality
evaluated at $0$ and $c(n)=P$, the reason we choose these bounds is because

#+NAME: tmp2
#+HEADER: :exports none :results output :session
#+HEADER: :dir (org-sbe container-dir-str)
#+BEGIN_SRC python
  s = {
      f: 3,
      r: 1,
      P: 70
  }
  var('lam', latex_name="\\alpha")
  var('x_p')
  var('y_p')

  cc = -1 * compound_interest_with_iterative_penalty
  cc = cc.subs(s)

  def jensins_inequality(func, a, b):
      return func.subs({n: lam * a + (1 - lam) * b}) >= lam * func.subs({n:a}) + (1 - lam) * func.subs({n:b})

  a = 1e-8
  b = P # solve((compound_interest_with_iterative_penalty==P).subs(s), n)[0].rhs()
  ji = jensins_inequality(cc, a, b)
  print(
      latex_center(
          latex(ji)
      )
  )

  #beep = c(lam * x_p + (1 - lam) * y_p) <= lam * c(x_p) + (1 - lam) * c(y_p)
  #print(beep)
  #assume(n, 'real')
  #print(solve(simplify(cc.subs({n: (1 - lam) * (70/3.0)}).subs(s) <= (lam * -P + (1 - lam) * -P).subs(s)), lam, domain='real'))
  #asdfasdf = simplify(cc.subs({n: (1 - lam) * (70/3.0)}).subs(s) - (lam * -P + (1 - lam) * -P).subs(s))
  #print(asdfasdf)
  #filename = '/mnt/g.png'
  #g = Graphics()
  #g += plot(asdfasdf, (lam, 0, 1))
  #g.save(filename=filename)
  #print(f"Filename: {filename}")
  #print(simplify(cc.subs({n: (1 - lam) * (70/3.0)}).subs(s) <= (lam * -P + (1 - lam) * -P).subs(s)).subs({lam: 0}))
  #print(simplify(cc.subs({n: (1 - lam) * (70/3.0)}).subs(s) <= (lam * -P + (1 - lam) * -P).subs(s)).subs({lam: 0.5}))
  #print(simplify(cc.subs({n: (1 - lam) * (70/3.0)}).subs(s) <= (lam * -P + (1 - lam) * -P).subs(s)).subs({lam: 0.999}))
#+END_SRC

#+RESULTS: tmp2
:
:  \begin{alignedat}{2}
:  3 \, P {\left({\alpha} - 1\right)} - 3 \, {\left(P {\left({\alpha} - 1\right)} - \left(1 \times 10^{-08}\right) \, {\alpha}\right)} \left(\frac{P {\left({\alpha} - 1\right)} - \left(1 \times 10^{-08}\right) \, {\alpha} - 1}{P {\left({\alpha} - 1\right)} - \left(1 \times 10^{-08}\right) \, {\alpha}}\right)^{-P {\left({\alpha} - 1\right)} + \left(1 \times 10^{-08}\right) \, {\alpha}} - \left(3.0000000000000004 \times 10^{-08}\right) \, {\alpha} - 70 \, {\left(-\frac{1}{P {\left({\alpha} - 1\right)} - \left(1 \times 10^{-08}\right) \, {\alpha}} + 1\right)}^{-P {\left({\alpha} - 1\right)} + \left(1 \times 10^{-08}\right) \, {\alpha}} \geq -{\left(3 \, P \left(\frac{P + 1}{P}\right)^{P} - 3 \, P - 70 \, {\left(\frac{1}{P} + 1\right)}^{P}\right)} {\left({\alpha} - 1\right)} - 70.0000128944777 \, {\alpha}
:  \end{alignedat}

#+MACRO: tmp2 (eval (latex-display-wrap (org-sbe tmp2)))

{{{tmp2()}}}

Now it might not look like it, but graphing both sides of this inequality shows
that this expression is true for $0 \lt \alpha \lt 1$ meaning that this function
IS convex.

* Environment teardown                                             :noexport:

#+HEADER: :exports none
#+begin_src sh :var NAME=(org-table-get-constant "container_name") :var SHUTDOWN=(org-table-get-constant "shutdown-env")
# [[ $SHUTDOWN ]] && podman kill $NAME; podman rm $NAME
#+end_src

#+RESULTS:
: compounder
