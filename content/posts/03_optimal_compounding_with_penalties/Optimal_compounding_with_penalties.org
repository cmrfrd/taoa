#+TITLE: Optimal compounding with penalties
#+CREATED: [2021-08-11 Wed 00:48]
#+LAST_MODIFIED: [2021-11-02 Tue 20:07]
#+ROAM_TAGS: money composition
#+STARTUP: showall indent
#+OPTIONS: toc:nil
#+OPTIONS: tex:t
#+OPTIONS: ^:nil p:nil

#+HUGO_BASE_DIR: ./
#+hugo_front_matter_format: yaml
#+HUGO_CUSTOM_FRONT_MATTER: :date (org-to-blog-date (org-global-prop-value "CREATED"))
#+HUGO_CUSTOM_FRONT_MATTER: :hero ./images/hero.jpg
#+HUGO_CUSTOM_FRONT_MATTER: :secret false
#+HUGO_CUSTOM_FRONT_MATTER: :excerpt Making money with your money's money

* Forward for the author                                           :noexport:

This post has a heavy focus on technical literate programming. This documents
goal is too produce two products. One for the author/developer and one for the
reader. The author's version gets to view the document in full, while the
reader's view is only the exported version. The explicit pieces that not
exported (and therefore hidden from the reader's view) are those which are not
directly relevant to the content of the article. This includes tools for the
author, exporting functionality, tests, configuration, etc.

** Exporting

#+BEGIN_SRC emacs-lisp :exports none
  ;; All inline code blocks will be latex
  (setq org-babel-inline-result-wrap "$%s$")

  ;; Configure languages
  (org-babel-do-load-languages
   'org-babel-load-languages
   '((shell . t)
     (python . t)))

  (defun org-hugo-link (link contents info) (org-md-link link contents info))

  ;; Setup org/latex exporting
  (add-to-list 'org-export-filter-latex-fragment-functions
               'sub-paren-for-dollar-sign)
  (add-to-list 'org-export-filter-headline-functions
               'remove-regexp-curly-braces)
  (add-to-list 'org-export-filter-latex-environment-functions
               'sub-paren-for-dollar-sign)
  (export-to-mdx-on-save)
#+END_SRC

#+RESULTS:
: Disabled mdx on save

** Configuration

The primary language we will be using is python inside of a container, org mode
(with TRAMP) has the fantastic feature of being able to execute src code blocks
inside a container which we will be leveraging for this post to the purpose of
isolation.

#+CONSTANTS: image_name=compounder container_name=compounder

#+NAME: container-dir-str
#+HEADER: :exports none :cache yes
#+begin_src emacs-lisp
  (setq shutdown-env nil)
  (setq docker-tramp-docker-executable "podman")
  (docker-tramp-add-method)
  (setq ob-ipython-command "ipython")
  ;;(setq org-babel-python-command "ipython --no-banner --classic --no-confirm-exit")
  (setq org-babel-python-command "ipython")
  (setq py-default-interpreter "ipython")
  (setq container-dir-str (format "/docker:sage@%s:/mnt" (org-table-get-constant "container_name")))
#+end_src

#+RESULTS[3e230263b74e67d7f6da938ba254721b1067098e]: container-dir-str
: /docker:sage@compounder:/mnt

** Environment setup

As mentioned we will be running the following code inside a container. Here we
setup our base container as sagemath, install some necessary package, and a
interactive python session with the starting variables

#+NAME: compounder-environment-build
#+HEADER: :exports code :padline no
#+BEGIN_SRC podman-build :dir "." :tangle (make-temp-name "Dockerfile-") :tag (org-table-get-constant "image_name")
  FROM sagemath/sagemath:latest
  USER root
  RUN apt-get update && \
      apt install vtk6 libvtk6.2 cmake -y && \
      rm -rf /var/lib/apt/lists/*
  USER sage
  RUN sage -python3 -m pip install sympy_plot_backends kaleido cvxpy
  RUN echo "$(date): Done!"
#+END_SRC

#+RESULTS: compounder-environment-build
: #<window 60 on /tmp/babel-zW5Yt6/ob-podman-build-out-QQzrR2>

#+NAME: compounder-environment-start
#+HEADER: :exports none
#+begin_src bash :results verbatim :var NAME=(org-table-get-constant "container_name")
  echo "Running container if not already running ..."
  [ ! "$(podman ps | grep $NAME)" ] && \
    (podman run \
           -d \
           -u $(id -u):$(id -g) \
           --userns keep-id \
           --name $NAME \
           --rm \
           --net host \
           -v $(pwd):/mnt \
           -w /mnt \
           -it compounder:latest; \
    echo "Container starting...") \
    || \
    echo "Container already running..."
#+end_src

#+RESULTS: compounder-environment-start
: Running container if not already running ...
: Container already running...

* Cryptocurrency "dividends"? ðŸ¤”

Most people who are "in the know" of the cryptocurrency world have probobaly
heard of the various ways to earn "dividends" from their holdings. By leveraging
earning protocols such as staking, lending, or Liquidity Pools fees, people can
just sit back and accrue tokens, increasing their portfolios value. This is
starkly different from the norm, which is just to HODL too the moon.

Earners that continually invest their returns back into these earning protocols
benefit from the :sparkles:magic:sparkles: that is compound interest.

Unfortunately since cryptocurrency/blockchain projects are pay to play, every
time an earner wants to interact with an earning protocol, they need to pay a fee to
do so. In short: You need to spend tokens, to make tokens ...

This begs the question: How do we spend the least to make the most?

* Abstracting earning protocols

There are many methods to earn "dividends" from cryptocurrency. However most
earning protocols expose the same metrics which we will use to our advantage. To
start, we will abstract out the following paramaters to model an earning protocol:

#+NAME: compounder-session-start
#+HEADER: :exports none :results output
#+BEGIN_SRC python :dir (org-sbe container-dir-str) :session
  import sympy
  from sage.all import *
  from sage.plot.plot3d.plot3d import axes
  from sage.numerical.optimize import minimize
  from sage.manifolds.utilities import set_axes_labels

  P, f, r, i, n, t = var("P f r i n t")
  Ps = var('P', n=5)
  assume(P > 0)
  assume(f > 0)
  assume(r > 0)
  print("Params initialized ...")

  latex_center = lambda expr: \
    '\n' + \
    LatexExpr("\\begin{alignedat}{2}") + \
    '\n' + \
    expr + \
    '\n' + \
    LatexExpr("\\end{alignedat}") + \
    '\n'

  latex_centers = lambda *exprs: \
    '\n' + \
    LatexExpr("\\begin{alignedat}{2}") + \
    '\n' + \
    ' \\\\ \n'.join(exprs) + \
    ' \\\\ \n' + \
    LatexExpr("\\end{alignedat}") + \
    '\n'

  latex_right = lambda a, b: a + LatexExpr(" \\rightarrow ") + b

  latex_lim = lambda expr, a, b: \
    LatexExpr("\\lim\\limits_{") + \
    a + \
    LatexExpr("\\rightarrow") + \
    b + \
    LatexExpr("}") + \
    expr
#+END_SRC

#+RESULTS[97baf44d19a33f07bad8a57c3399bba81473e8b2]: compounder-session-start
: Params initialized ...

- src_python[:results output :session :dir (org-sbe
  container-dir-str)]{print(latex(t))} {{{results(t)}}} - Time until compound (in years)
- src_python[:results output :session :dir (org-sbe
  container-dir-str)]{print(latex(n))} {{{results(n)}}} - Number of compounds
  per year
- src_python[:results output :session :dir (org-sbe
  container-dir-str)]{print(latex(P))} {{{results($P$)}}} - Initial balance
- src_python[:results output :session :dir (org-sbe
  container-dir-str)]{print(latex(r))} {{{results($r$)}}} - APR
- src_python[:results output :session :dir (org-sbe
  container-dir-str)]{print(latex(f))} {{{results($f$)}}} - Fee per compound

Using these base paramaters let begin to derive an expression to calculate earnings.

* Deriving compound interest with iterative penalties

Lets start by creating an expression to model our earnings are after we compound
once at time src_python[:results output :session :dir (org-sbe
container-dir-str)]{print(latex(t))}. This can be trivially described as
follows.

#+NAME: earning-over-time-1
#+HEADER: :exports none :results output
#+BEGIN_SRC python :dir (org-sbe container-dir-str) :session
  print(
      latex_centers(
          latex(Ps[1] == Ps[0] + (Ps[0]*r*t) - f),
          latex(Ps[2] == Ps[1] + (Ps[1]*r*t) - f),
          latex(Ps[2] == (Ps[0] + (Ps[0]*r*t) - f + ((Ps[0] + (Ps[0]*r*t) - f)*r*t) - f).simplify_full())
      )
  )
#+END_SRC

#+RESULTS: earning-over-time-1
:
:  \begin{alignedat}{2}
:  P_{1} = P_{0} r t + P_{0} - f \\
: P_{2} = P_{1} r t + P_{1} - f \\
: P_{2} = P_{0} r^{2} t^{2} + {\left(2 \, P_{0} - f\right)} r t + P_{0} - 2 \, f \\
:  \end{alignedat}

Where src_python[:results output :session :dir (org-sbe
container-dir-str)]{print(latex(Ps[0]))} is our initial balance and
src_python[:results output :session :dir (org-sbe
container-dir-str)]{print(latex(Ps[1]))} is the balance after compounding. If we
wait time src_python[:results output :session :dir (org-sbe
container-dir-str)]{print(latex(t))} again before our second compounding we get
the expressions

#+NAME: earning-over-time-2
#+HEADER: :exports none :results output
#+BEGIN_SRC python :dir (org-sbe container-dir-str) :session
  print(latex(Ps[1] == Ps[0] + (Ps[0]*r*t) - f))
#+END_SRC


#+NAME: compound-interest
#+HEADER: :exports none :results output
#+BEGIN_SRC python :dir (org-sbe container-dir-str) :session
  compound_interest = ( P * ( 1 + ( r / n ) ) ** n )
  compound_interest_latex = latex_center(latex(compound_interest))
  print(compound_interest_latex)
#+END_SRC

#+RESULTS: compound-interest
:
:  \begin{alignedat}{2}
:  P {\left(\frac{r}{n} + 1\right)}^{n}
:  \end{alignedat}

#+MACRO: compound-interest (eval (latex-display-wrap (org-sbe compound-interest)))

{{{compound-interest()}}}

While this is all well and good, we want to account for the fact that whenever
we want to "compound" our pending earnings, we need pay a fee to do so. With
this in mind we need to come up with an expression to account for each
penalization fee src_python[:results output :session  :dir (org-sbe
container-dir-str)]{print(latex(f))} {{{results(f)}}} over each compounding
instance src_python[:results output :session  :dir (org-sbe
container-dir-str)]{print(latex(n))} {{{results($n$)}}}.

To do this we will add on the idea of iterative penalties which is the summation
of fees across every compounding instance.

#+NAME: iterative-penalty
#+HEADER: :exports none :results output
#+BEGIN_SRC python :dir (org-sbe container-dir-str) :session
iterative_penalty = ( f * sum( (1 + (r / n))**i , i, 0, n-1, hold=True) )
print(latex_center(latex(iterative_penalty)))
#+END_SRC

#+RESULTS: iterative-penalty
:
:  \begin{alignedat}{2}
:  f {\sum_{i=0}^{n - 1} {\left(\frac{r}{n} + 1\right)}^{i}}
:  \end{alignedat}

#+MACRO: iterative-penalty (eval (latex-display-wrap (org-sbe iterative-penalty)))

{{{iterative-penalty()}}}

By subtracting the interative penalty fees from compound interest, we get the
following expression.

#+NAME: compound-interest-with-iterative-penalty-verbose
#+HEADER: :exports none :results output
#+BEGIN_SRC python :dir (org-sbe container-dir-str) :session
  compound_interest_with_iterative_penalty = compound_interest - iterative_penalty
  print(latex_center(latex(compound_interest_with_iterative_penalty)))
#+END_SRC

#+NAME: compound-interest-with-iterative-penalty-verbose
#+RESULTS: compound-interest-with-iterative-penalty-verbose
:
:  \begin{alignedat}{2}
:  P {\left(\frac{r}{n} + 1\right)}^{n} - f {\sum_{i=0}^{n - 1} {\left(\frac{r}{n} + 1\right)}^{i}}
:  \end{alignedat}

#+MACRO: compound-interest-with-iterative-penalty-verbose (eval (latex-display-wrap (org-sbe compound-interest-with-iterative-penalty-verbose)))

{{{compound-interest-with-iterative-penalty-verbose()}}}

Simplifying we can define the function $ciwip$ as the following expression

#+NAME: compound-interest-with-iterative-penalty-simple
#+HEADER: :exports none :results output
#+BEGIN_SRC python :dir (org-sbe container-dir-str) :session
  compound_interest_with_iterative_penalty = compound_interest - iterative_penalty.unhold()
  ciwip, c = function('ciwip'), function('c')
  print(latex_center(latex(ciwip(P,f,r,n) == compound_interest - iterative_penalty.unhold())))
#+END_SRC

#+RESULTS[92dcf708f6a8d7e37d1096957d942ffc9645a2ff]: compound-interest-with-iterative-penalty-simple
:
:  \begin{alignedat}{2}
:  {\rm ciwip}\left(P, f, r, n\right) = P {\left(\frac{r}{n} + 1\right)}^{n} - \frac{{\left(n \left(\frac{n + r}{n}\right)^{n} - n\right)} f}{r}
:  \end{alignedat}

#+MACRO: compound-interest-with-iterative-penalty-simple (eval (latex-display-wrap (org-sbe compound-interest-with-iterative-penalty-simple)))

{{{compound-interest-with-iterative-penalty-simple()}}}

* Visualization! :chart_with_upwards_trend:

Now that we have an expression to model an earning protocol, lets try to gain
some intuition about how they work with some visualizations! It seems most
reasonable to start with a 2D plot dependent on src_python[:results output
:session :dir (org-sbe container-dir-str)]{print(latex(n))} because it's the
only paramater that we can control once we put a deposit into an earning
protocol. Holding all the other parameters constant with some random values, we
get the following plot.

#+NAME: ciwip-func-def
#+HEADER: :exports none :results output
#+begin_src python :dir (org-sbe container-dir-str) :session
  def optimal_compound_interest_with_iterative_penalty(P_, f_, r_, astype=float):

      ## Formula for ciwip
      P, f, r, i, n = var("P f r i n")
      compound_interest = ( P * ( 1 + ( r / n ) ) ** n )
      iterative_penalty = ( f * sum( (1 + (r / n))**i , i, 0, n-1) )
      compound_interest_with_iterative_penalty = compound_interest - iterative_penalty

      ## Compute ciwip from params and minimize
      ciwip_min_ = -1.0 * compound_interest_with_iterative_penalty.substitute(P=P_, f=f_, r=r_)
      ciwip_min_result = sage.numerical.optimize.minimize(
          ciwip_min_,
          [1e-10],
          algorithm='bfgs',
          gradient=ciwip_min_.diff()
      )
      if astype == float:
          return ciwip_min_result[0]
      elif astype == int:
          if compound_interest_with_iterative_penalty.substitute(P=P_, f=f_, r=r_, n=floor(ciwip_min_result[0])) > \
              compound_interest_with_iterative_penalty.substitute(P=P_, f=f_, r=r_, n=ceil(ciwip_min_result[0])):
              return floor(ciwip_min_result[0])
          else:
              return ceil(ciwip_min_result[0])
      else:
          raise Exception(f"{astype} unsupported")
#+end_src

#+RESULTS: ciwip-func-def

#+NAME: compound-interest-with-iterative-penalty-plot
#+HEADER: :exports none :results output
#+BEGIN_SRC python :dir (org-sbe container-dir-str) :session
  from spb.backends.plotly import PB
  from spb import plot as spb_plot

  P, f, r, i, n = var("P f r i n")
  compound_interest = ( abs(P) * ( 1 + ( abs(r) / abs(n) ) ) ** abs(n) )
  iterative_penalty = ( (abs(f) * sum( (1 + (abs(r) / abs(n)))**i , i, 0, n-1) ) )
  compound_interest_with_iterative_penalty = compound_interest - iterative_penalty

  compound_interest_with_iterative_penalty = \
    abs(P)*(abs(r)/abs(n) + 1)**abs(n) - (((abs(r) + abs(n))/abs(n))**abs(n)*abs(n) - abs(n))*abs(f)/abs(r)

  title = "Compound interest with iterative penalty"
  filename = f'{title.lower().replace(" ","-")}-plot.png'
  params = {
      P: 100,
      r: 0.8,
      f: 4
  }
  params_by_str = {str(k): v for k,v in params.items()}
  params_tex_str = ' | '.join(f'{p}={v}' for p,v in params.items())
  taytay = compound_interest_with_iterative_penalty.taylor(n, (P*r)/(f*2), 1).subs(params)
  bb = solve((compound_interest_with_iterative_penalty==P), n)[0].rhs()
  pl = spb_plot(
      (compound_interest_with_iterative_penalty.subs(params), (n, 0, 40)),
      title=f"$\\text{{{title}}} \\\\ \\text{{{params_tex_str}}}$",
      show=False,
      use_latex=True,
      legend=False,
      theme="plotly",
      xlabel=f"${n}$",
      ylabel=f"${ciwip}$",
      ylim=(0, params[P] * 2),
      backend=PB
  )
  pl._update_layout()
  pl._fig.update_layout(
      title_x=0.09,
      margin=dict(
          l=70,
          r=50,
          b=70,
          t=100,
          pad = 4
      )
  )
  pl._process_series(pl._series)
  pl._fig.write_image(filename)
  print(f"Filename: {filename}")
#+END_SRC

#+RESULTS: compound-interest-with-iterative-penalty-plot
: Filename: compound-interest-with-iterative-penalty-plot.png

#+CAPTION: 2D view of compound interest with iterative penalties
[[./compound-interest-with-iterative-penalty-plot.png]]

With this 2D view we can now get a better understanding of what optimal
compounding really means.

The first intuition we can take away is that as we tend src_python[:results
output :session :dir (org-sbe container-dir-str)]{print(latex_right(latex(n),
latex(oo)))} {{{results($n \rightarrow +\infty$)}}} we see that our output value
tends towards negative infinity meaning we lose more than we are gaining (which
we don't want). However there is an inflection point at (around
src_python[:results output :session :dir (org-sbe
container-dir-str)]{print(latex(n==round(optimal_compound_interest_with_iterative_penalty(params_by_str['P'],
params_by_str['f'], params_by_str['r']), 2)))} {{{results($n = 2.79$)}}}) where
we make *more* than we lose. This means that by compounding at the right
frequency we can profit from the accrued rewards than the fee we need to pay to
claim them.

Now we can return to original question at the begginning: "how do we spend the
least too make the most?". The answer we can infer from this plot if "choose the
right src_python[:results output :session :dir (org-sbe
container-dir-str)]{print(latex(n))} {{{results($n$)}}}".

*Aside* - Something interesting to note is that as we tend src_python[:results
output :session :dir (org-sbe container-dir-str)]{print(latex_right(latex(n),
latex(oo)))} it looks like our function starts to becomes linear. We can prove
this if we take the limit of the derivative of our function. We can see it's
independent of src_python[:results output :session :dir (org-sbe
container-dir-str)]{print(latex(n))} {{{results($n$)}}} meaning that even though
compounding to infinity means we will keep losing, we will eventually lose at a
constant rate.

#+NAME: compound-interest-with-iterative-penalty-zero-limit-analysis
#+HEADER: :exports none :results output
#+BEGIN_SRC python :dir (org-sbe container-dir-str) :session
  print(
      latex_center(
          latex_lim(
              latex(
                  ciwip(P,f,r,n).derivative(n) == \
                  limit(compound_interest_with_iterative_penalty.derivative(n),n=oo)
              ),
              latex(n),
              latex(oo)
          )
      )
  )
#+END_SRC

#+RESULTS: compound-interest-with-iterative-penalty-zero-limit-analysis
:
:  \begin{alignedat}{2}
:  \lim\limits_{ n \rightarrow +\infty } \frac{\partial}{\partial n}{\rm ciwip}\left(P, f, r, n\right) = -\frac{f e^{r} - f}{r}
:  \end{alignedat}

#+MACRO: compound-interest-with-iterative-penalty-zero-limit-analysis (eval (latex-display-wrap (org-sbe compound-interest-with-iterative-penalty-zero-limit-analysis)))

{{{compound-interest-with-iterative-penalty-zero-limit-analysis()}}}

For the example above we used fixed parameters, but what if we changed them to
be higher or lower? How would our plot change? Would we still see the same
shape? To learn a little more about the shape of this function, lets unify all
the paramaters we can't control under some var src_python[:results output
:session :dir (org-sbe container-dir-str)]{print(latex(C))} {{{results($C$)}}}
and plot what we have left in 3D.

Doing so will give us the following expression:

#+NAME: homogenized-compound-interest-with-iterative-penalty
#+HEADER: :exports none :results output
#+BEGIN_SRC python :dir (org-sbe container-dir-str) :session
  C = var('C')
  homogenized_compound_interest_with_iterative_penalty = compound_interest_with_iterative_penalty.substitute(P=C, f=C, r=C)
  const_sympy = homogenized_compound_interest_with_iterative_penalty._sympy_()
  const_sympy_vars = {str(i): i for i in const_sympy.free_symbols}
  print(latex_center(latex(homogenized_compound_interest_with_iterative_penalty)))
#+END_SRC

#+RESULTS: homogenized-compound-interest-with-iterative-penalty
:
:  \begin{alignedat}{2}
:  C {\left(\frac{C}{{\left| n \right|}} + 1\right)}^{{\left| n \right|}} - \left(\frac{C + {\left| n \right|}}{{\left| n \right|}}\right)^{{\left| n \right|}} {\left| n \right|} + {\left| n \right|}
:  \end{alignedat}

#+MACRO: homogenized-compound-interest-with-iterative-penalty (eval (latex-display-wrap (org-sbe homogenized-compound-interest-with-iterative-penalty)))

{{{homogenized-compound-interest-with-iterative-penalty()}}}

#+NAME: homogenized-compound-interest-with-iterative-penalty-plot
#+HEADER: :exports none :results output
#+begin_src python :dir (org-sbe container-dir-str) :session
  import numpy as np
  import plotly.graph_objects as go
  from plotly.subplots import make_subplots

  def get_plane(M, v, xx, yy, zz):

      # M point contained by the plane
      # v direction included in plane (orthogonal to w=[0, 0, 1])
      x0, y0, _= M
      a, b, _= v

      if a == 0 and b != 0:
          Y, Z = np.meshgrid(yy, zz)
          X = x0*np.ones(Y.shape)
      elif a != 0 and b==0:
          X, Z = np.meshgrid(xx, zz)
          Y = y0*np.ones(X.shape)
      else:
          X, Z = np.meshgrid(xx, zz)
          Y = y0+b*(X-x0)/a
      return X, Y, Z


  # define xy mesh and z func output
  xx = np.linspace(2, 12, 50)
  yy = np.linspace(2, 12, 50)
  x,y = np.meshgrid(xx, yy)
  fff = sympy.lambdify((const_sympy_vars["n"], const_sympy_vars["C"]), const_sympy, "numpy")
  z = fff(x, y)
  zz = np.linspace(z.min(), z.max(), 50)

  M = [0, 11, 0]  # a point in the plane
  v = [1, 0, 0] # a direction contained in the plane
  X, Y, Z =  get_plane(M, v, xx, yy, zz)

  fig = make_subplots(
       rows=1, cols=1,
       horizontal_spacing=0.1)
  fig.add_trace(go.Surface(x=x,
                           y=y,
                           z=z,
                           colorscale="Viridis",
                           lighting=dict(diffuse=0.9),
                           showscale=False))
  fig.add_trace(go.Surface(x=X, y=Y, z=Z,
                           colorscale= [[0, "rgb(254, 254, 254)"],
                                        [1, "rgb(254, 254, 254)"]],
                           showscale=False,
                           lighting=dict(diffuse=0.9),
                           opacity=0.3))
  fig.update_layout(
      scene_camera=dict(
        eye=dict(x=2, y=2.5, z=2.3)
      ),
      margin=dict(t=0, r=0, l=0, b=0),
      width=600, height=600, yaxis = {"domain":  [0, 0.85]},
      scene = dict(
                    xaxis_title='n',
                    yaxis_title='C',
                    zaxis_title='$')
  )
  fig.update_xaxes(autorange="reversed")
  fig.update_xaxes(range=[12, 1])
  fig.update_scenes(xaxis_autorange="reversed")
  fig.update_scenes(yaxis_autorange="reversed")
  fig.write_image("homogenized-compound-interest-with-iterative-penalty-plot.png")
  print("done!")
#+end_src

#+RESULTS: homogenized-compound-interest-with-iterative-penalty-plot
: done!

#+CAPTION: A surface 3d plot of homogenized compound interest with iterative penalties
[[./homogenized-compound-interest-with-iterative-penalty-plot.png]]

The interesting thing we can observe is that if we hold the variables we can't
control constant (via src_python[:results output :session :dir (org-sbe
container-dir-str)]{print(latex(C))} {{{results($C$)}}}) and represent some
choice src_python[:results output :session :dir (org-sbe
container-dir-str)]{print(latex(C))} by slicing the space with a plane (shown by
the slightly opaque vertical plane), the corresponding cross section is the
space of possibile results of our balance as a consequence of choosing some
src_python[:results output :session :dir (org-sbe
container-dir-str)]{print(latex(n))}. Looking closely, there seems to be a
similar shape between the intersection and the 2D plot, and if we slide the
opaque plane up and down the src_python[:results output :session :dir (org-sbe
container-dir-str)]{print(latex(C))} axis, the shape seems consistant. However
this empirical observation doesn't prove anything. Instead let's define a narrow
problem we want to solve for, and prove a property about the problem.

* In search of optimality! â›°

We showed in the previous section that when we chose some fixed parameters for
our src_python[:results output :session :dir (org-sbe
container-dir-str)]{print(latex(ciwip()))} {{{results(${\rm
ciwip}\left(\right)$)}}} function, there was an optimal src_python[:results
output :session :dir (org-sbe container-dir-str)]{print(latex(n))} that enables
us to earn more than we lose. This is obviously an ideal case which we want to
happen all the time! Unfortunately, in reality, our "fixed" parameters aren't so
"fixed". What we really want to know is for any reasonable set of parameters,
can we find the optimal value that is greater than our initial balance?

** Avoiding losses

One initial direction we can take to simplify our problem is to find all the
places where we lose more than we gain.

We know that the space of possible compounds is from src_python[:results output
:session :dir (org-sbe container-dir-str)]{print(latex_right(latex(0),
latex(oo)))} {{{results(0 \rightarrow +\infty)}}} and we've already established
that as we compound more and more we get diminishing returns, then eventually
substantial losses. To avoid these losses we need to see where
src_python[:results output :session :dir (org-sbe
container-dir-str)]{print(latex(ciwip(P,r,f,n)<P))} {{{results(${\rm
ciwip}\left(P\, r\, f\, n\right) < P$)}}}. We can observe from our 2D graph of
src_python[:results output :session :dir (org-sbe
container-dir-str)]{print(latex(ciwip))} that src_python[:results output
:session :dir (org-sbe container-dir-str)]{print(latex(P))} is intersected
twice, first at src_python[:results output :session :dir (org-sbe
container-dir-str)]{print(latex(0))} {{{results($0$)}}} and second at
src_python[:results output :session :dir (org-sbe
container-dir-str)]{print(latex(n==(P*r/f).subs(params)))} {{{results($n =
20.0$)}}}. Now based on what we know about this function, it makes sense that
there will always be two points where src_python[:results output :session :dir
(org-sbe container-dir-str)]{print(latex(ciwip(P,r,f,n)==P))}. One for when we
don't compound at all and stay at our initial balance, and one for when we are
compounding too much to the point where we end up "net even". This second "net
even" point is important because with it we can show that compounding past it
will always lead to losses. To find this point we can take src_python[:results
output :session :dir (org-sbe
container-dir-str)]{print(latex(ciwip(P,r,f,n)==P))}, and simply solve for
src_python[:results output :session :dir (org-sbe
container-dir-str)]{print(latex(n))}. Doing so gets us the expression.

#+NAME: net-even
#+HEADER: :exports none :results output
#+BEGIN_SRC python :dir (org-sbe container-dir-str) :session
  net_even_n = solve((compound_interest_with_iterative_penalty==P), n)[0]
  print(latex(net_even_n))
#+END_SRC

#+RESULTS: net-even
: {\left| n \right|} = \frac{P r}{f}

Which means all we need to do it show is that if we compound above this "net
even" point with some positive src_python[:results output :session :dir (org-sbe
container-dir-str)]{print(latex(eps))} {{{results(${\epsilon}$)}}}, we will
always get less than our initial balance src_python[:results output :session
:dir (org-sbe container-dir-str)]{print(latex(P))}. If we put this into an
expression we get:

#+NAME: net-loss
#+HEADER: :exports none :results output
#+BEGIN_SRC python :dir (org-sbe container-dir-str) :session
  eps = var("eps", latex_name="\\epsilon")
  print(latex(ciwip(P,f,r,net_even_n.rhs() + eps) < P))
#+END_SRC

#+RESULTS: net-loss
: {\rm ciwip}\left(P, f, r, {\epsilon} + \frac{P r}{f}\right) < P

And if we follow the substitution and replacement we get the expression:

#+NAME: net-loss-proven
#+HEADER: :exports none :results output
#+BEGIN_SRC python :dir (org-sbe container-dir-str) :session
  import sympy as S
  from sympy import UnevaluatedExpr, simplify
  eq = (compound_interest_with_iterative_penalty.subs({n:(P*r/f) + eps}) - P).simplify_full()
  reformatted_eq = (-(eps*f/r)) * ( ((eps*f + (P + f)*r)/(eps*f + P*r))**(eps + P*r/f) - 1 )
  uneval_reformatted_eq = UnevaluatedExpr(-(eps*f/r)) * UnevaluatedExpr( ((eps*f + (P + f)*r)/(eps*f + P*r))**(eps + P*r/f) - 1 )
  assert bool(simplify( eq._sympy_() - reformatted_eq ) == 0 )
  print(S.latex(uneval_reformatted_eq < 0).replace("eps", "\\epsilon"))
#+END_SRC

#+RESULTS: net-loss-proven
: - \frac{\epsilon f}{r} \left(\left(\frac{\epsilon f + r \left(P + f\right)}{P r + \epsilon f}\right)^{\frac{P r}{f} + \epsilon} - 1\right) < 0

This expression will always hold true as long as all the components are positive
real values (which we've already established is true in our framing of our
problem).

This allows us to conclude that compounding for src_python[:results output :session :dir
(org-sbe container-dir-str)]{print(latex(net_even_n.rhs() + eps))} for any
src_python[:results output :session :dir (org-sbe
container-dir-str)]{print(latex(eps>0))} we will always end up with less than
our original balance.

** Convexity

In order to find out if this function is truley convex, we can leverage Jensen's
inequality and check if the inequality is true.

#+NAME: jensins-inequality
#+HEADER: :exports none :results output
#+BEGIN_SRC python :dir (org-sbe container-dir-str) :session
  def jensins_inequality(func=None, a=None, b=None):
      if func is None:
          func = function("f")
      if a is None:
          a = var("x_1")
      if b is None:
          b = var("x_2")

      lam = var('lam', latex_name="\\lambda")
      return \
          func(lam * a + (1 - lam) * b) \
          <= \
          lam * func(a) + (1 - lam) * func(b)

  print(
      latex_center(
          latex(jensins_inequality())
      )
  )
#+END_SRC

#+RESULTS: jensins-inequality
:
:  \begin{alignedat}{2}
:  f\left({\lambda} x_{1} - {\left({\lambda} - 1\right)} x_{2}\right) \leq {\lambda} f\left(x_{1}\right) - {\left({\lambda} - 1\right)} f\left(x_{2}\right)
:  \end{alignedat}

#+MACRO: jensins-inequality (eval (latex-display-wrap (org-sbe jensins-inequality)))

{{{jensins-inequality()}}}

If we substitute our function into jensins inequality and supply our bounds
(ignoring everything but the src_python[:results output :session :dir (org-sbe
container-dir-str)]{print(latex(n))} parameter we get:

#+NAME: ciwip-jensins-inequality
#+HEADER: :exports none :results output
#+BEGIN_SRC python :dir (org-sbe container-dir-str) :session
  print(
      latex_center(
          latex(jensins_inequality(ciwip, 0, P*r/f))
      )
  )
#+END_SRC

#+RESULTS: ciwip-jensins-inequality
:
:  \begin{alignedat}{2}
:  {\rm ciwip}\left(-\frac{P {\left({\alpha} - 1\right)} r}{f}\right) \leq {\alpha} {\rm ciwip}\left(0\right) - {\left({\alpha} - 1\right)} {\rm ciwip}\left(\frac{P r}{f}\right)
:  \end{alignedat}

substituting further and reducing we get the expression:

#+NAME: substituted-ciwip-jensins-inequality
#+HEADER: :exports none :results output
#+BEGIN_SRC python :dir (org-sbe container-dir-str) :session
  a = 0
  b = P*r/f
  c = compound_interest_with_iterative_penalty
  lam = var('lam', latex_name="\\lambda")
  c_j = \
    ( c.subs({n:lam * a + (1 - lam) * b}) ).simplify_full() \
    > \
    ( lam * P + (1 - lam) * c.subs({n:b}) ).simplify_full()

  alpha = (P*abs(lam - 1) - P).mul(-1, hold=True)
  beta = ((c_j.lhs() - c_j.rhs())/(alpha)).simplify_full()
  print(latex((alpha * beta) > 0))
#+END_SRC

#+RESULTS: substituted-ciwip-jensins-inequality
: -{\left(P {\left| {\lambda} - 1 \right|} - P\right)} {\left(\left(\frac{P {\left| {\lambda} - 1 \right|} + f}{P {\left| {\lambda} - 1 \right|}}\right)^{\frac{P r {\left| {\lambda} - 1 \right|}}{f}} - 1\right)} > 0

This final inequality will tell us if our function src_python[:results output
:session :dir (org-sbe container-dir-str)]{print(latex(ciwip))} is convex or
not. It may not seem like it right away but this inequality will always be true
if our components are positive real values. Let's break down this expression a
bit more to see why.

#+NAME: vars-decomposed-ciwip-jensins-inequality
#+HEADER: :exports none :results output
#+BEGIN_SRC python :dir (org-sbe container-dir-str) :session
  alph = var('alph', latex_name="\\alpha")
  bet = var('bet', latex_name="\\beta")
#+END_SRC

#+RESULTS: vars-decomposed-ciwip-jensins-inequality

First lets decompose the left hand side of our expression into two components
src_python[:results output :session :dir (org-sbe
container-dir-str)]{print(latex(alph))} and src_python[:results output
:session :dir (org-sbe container-dir-str)]{print(latex(bet))} as follows:

#+NAME: decomposed-ciwip-jensins-inequality
#+HEADER: :exports none :results output
#+BEGIN_SRC python :dir (org-sbe container-dir-str) :session
  print(
      latex_centers(
          latex(alpha.unhold().simplify() == alph),
          latex(beta == bet),
          latex((alph * bet) > 0)
      )
  )
#+END_SRC

#+RESULTS: decomposed-ciwip-jensins-inequality
:
:  \begin{alignedat}{2}
:  -P {\left| {\lambda} - 1 \right|} + P = {\alpha} \\
: \left(\frac{P {\left| {\lambda} - 1 \right|} + f}{P {\left| {\lambda} - 1 \right|}}\right)^{\frac{P r {\left| {\lambda} - 1 \right|}}{f}} - 1 = {\beta} \\
: {\alpha} {\beta} > 0 \\
:  \end{alignedat}

Looking at our decomposition we can first observe that src_python[:results output
:session :dir (org-sbe container-dir-str)]{print(latex(alph>0)))} because the

#+NAME: ciwip-maximization
#+HEADER: :exports none :results output
#+BEGIN_SRC python :dir (org-sbe container-dir-str) :session
  P, r, f = 100, 0.8, 0.01
  balance = P
  ciwip = lambda P,r,f,n: P*(r/abs(n) + 1)**abs(n) - (((r + abs(n))/abs(n))**abs(n)*abs(n) - abs(n))*f/r if n != 0 else P
  for n in range(0, int(round(P*r/f))):
      new_balance = ciwip(P, r, f, n)
      if new_balance >= balance:
          balance = new_balance
      else:
          break

  print(f"Best number of compounds: {n}/yr with a final balance of {balance}")
#+END_SRC

#+RESULTS: ciwip-maximization
: Best number of compounds: 68/yr with a final balance of 220.48444917429077



* Environment teardown                                             :noexport:

#+HEADER: :exports none
#+begin_src sh :var NAME=(org-table-get-constant "container_name") :var SHUTDOWN=(org-table-get-constant "shutdown-env")
# [[ $SHUTDOWN ]] && podman kill $NAME; podman rm $NAME
#+end_src

#+RESULTS:
| compounder                                                       |
| 514dc2da37e88051d3bd8417bb6a9dc5879c43f60c53301fe2bc1f594c33d587 |
