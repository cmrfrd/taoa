#+TITLE: Optimal compounding with penalties
#+CREATED: [2021-08-11 Wed 00:48]
#+LAST_MODIFIED: [2021-10-18 Mon 00:25]
#+ROAM_TAGS: money composition
#+STARTUP: showall indent
#+OPTIONS: toc:nil
#+OPTIONS: tex:t
#+OPTIONS: ^:nil p:nil

#+HUGO_BASE_DIR: ./
#+hugo_front_matter_format: yaml
#+HUGO_CUSTOM_FRONT_MATTER: :date (org-to-blog-date (org-global-prop-value "CREATED"))
#+HUGO_CUSTOM_FRONT_MATTER: :hero ./images/hero.jpg
#+HUGO_CUSTOM_FRONT_MATTER: :secret false
#+HUGO_CUSTOM_FRONT_MATTER: :excerpt Making money with your money's money

* Forward for the author                                           :noexport:

This post has a heavy focus on technical literate programming. This documents
goal is too produce two products. One for the author/developer and one for the
reader. The author's version gets to view the document in full, while the
reader's view is only the exported version. The explicit pieces that not
exported (and therefore hidden from the reader's view) are those which are not
directly relevant to the content of the article. This includes tools for the
author, exporting functionality, tests, configuration, etc.

** Exporting

#+BEGIN_SRC emacs-lisp :exports none
  ;; All inline code blocks will be latex
  (setq org-babel-inline-result-wrap "$%s$")

  ;; Configure languages
  (org-babel-do-load-languages
   'org-babel-load-languages
   '((shell . t)
     (python . t)))

  (defun org-hugo-link (link contents info) (org-md-link link contents info))

  ;; Setup org/latex exporting
  (add-to-list 'org-export-filter-latex-fragment-functions
               'sub-paren-for-dollar-sign)
  (add-to-list 'org-export-filter-headline-functions
               'remove-regexp-curly-braces)
  (add-to-list 'org-export-filter-latex-environment-functions
               'sub-paren-for-dollar-sign)
  (export-to-mdx-on-save)
#+END_SRC

#+RESULTS:
: Enabled mdx on save

** Configuration

The primary language we will be using is python inside of a container, org mode
(with TRAMP) has the fantastic feature of being able to execute src code blocks
inside a container which we will be leveraging for this post to the purpose of
isolation.

#+CONSTANTS: image_name=compounder container_name=compounder

#+NAME: container-dir-str
#+HEADER: :exports none :cache yes
#+begin_src emacs-lisp
  (setq shutdown-env nil)
  (setq docker-tramp-docker-executable "podman")
  (docker-tramp-add-method)
  (setq ob-ipython-command "ipython")
  ;;(setq org-babel-python-command "ipython --no-banner --classic --no-confirm-exit")
  (setq org-babel-python-command "ipython")
  (setq py-default-interpreter "ipython")
  (setq container-dir-str (format "/docker:sage@%s:/mnt" (org-table-get-constant "container_name")))
#+end_src

#+RESULTS[3e230263b74e67d7f6da938ba254721b1067098e]: container-dir-str
: /docker:sage@compounder:/mnt

** Environment setup

As mentioned we will be running the following code inside a container. Here we
setup our base container as sagemath, install some necessary package, and a
interactive python session with the starting variables

#+NAME: compounder-environment-build
#+HEADER: :exports code :padline no
#+BEGIN_SRC podman-build :dir "." :tangle (make-temp-name "Dockerfile-") :tag (org-table-get-constant "image_name")
  FROM sagemath/sagemath:latest
  USER root
  RUN apt-get update && \
      apt install vtk6 libvtk6.2 cmake -y && \
      rm -rf /var/lib/apt/lists/*
  USER sage
  RUN sage -python3 -m pip install sympy_plot_backends kaleido cvxpy
  RUN echo "$(date): Done!"
#+END_SRC

#+RESULTS: compounder-environment-build
: #<window 16 on /tmp/babel-wksSJe/ob-podman-build-out-2IB5p5>

#+NAME: compounder-environment-start
#+HEADER: :exports none
#+begin_src bash :results verbatim :var NAME=(org-table-get-constant "container_name")
  echo "Running container if not already running ..."
  [ ! "$(podman ps | grep $NAME)" ] && \
    (podman run \
           -d \
           -u $(id -u):$(id -g) \
           --userns keep-id \
           --name $NAME \
           --rm \
           --net host \
           -v $(pwd):/mnt \
           -w /mnt \
           -it compounder:latest; \
    echo "Container starting...") \
    || \
    echo "Container already running..."
#+end_src

#+RESULTS: compounder-environment-start
: Running container if not already running ...
: ca6b503ad354cfcc576a71db9bd66c581179843e0b5295ba1ac225b7c4d742c3
: Container starting...

* Cryptocurrency "dividends"? ðŸ¤”

Most people who are "in the know" of the cryptocurrency world have probobaly
heard of the various ways to earn "dividends" from their holdings. By leveraging
earning protocols such as staking, lending, or Liquidity Pools fees, people can
just sit back and accrue tokens, increasing their portfolios value. This is
starkly different from the norm, which is just to HODL too the moon.

Earners that continually invest their returns back into these earning protocols
benefit from the :sparkles:magic:sparkles: that is compound interest.

Unfortunately since cryptocurrency/blockchain projects are pay to play, every
time an earner wants to interact with an earning protocol, they need to pay a fee to
do so. In short: You need to spend tokens, to make tokens ...

This begs the question: How do we spend the least to make the most?

* Abstracting earning protocols

There are many methods to earn "dividends" from cryptocurrency. However most
earning protocols expose the same metrics which we will use to our advantage. To
start, we will abstract out the following paramaters for an earning protocol:

#+NAME: compounder-session-start
#+HEADER: :exports none :results output
#+BEGIN_SRC python :dir (org-sbe container-dir-str) :session
  import sympy
  from sage.all import *
  from sage.plot.plot3d.plot3d import axes
  from sage.numerical.optimize import minimize
  from sage.manifolds.utilities import set_axes_labels

  P, f, r, i, n = var("P f r i n")
  assume(P > 0)
  assume(f > 0)
  assume(r > 0)
  print("Params initialized ...")

  latex_center = lambda expr: \
    '\n' + \
    LatexExpr("\\begin{alignedat}{2}") + \
    '\n' + \
    expr + \
    '\n' + \
    LatexExpr("\\end{alignedat}") + \
    '\n'

  latex_right = lambda a, b: a + LatexExpr(" \\rightarrow ") + b

  latex_lim = lambda expr, a, b: \
    LatexExpr("\\lim\\limits_{") + \
    a + \
    LatexExpr("\\rightarrow") + \
    b + \
    LatexExpr("}") + \
    expr
#+END_SRC

#+RESULTS[97baf44d19a33f07bad8a57c3399bba81473e8b2]: compounder-session-start
: Params initialized ...

- src_python[:results output :session :dir (org-sbe
  container-dir-str)]{print(latex(n))} {{{results($n$)}}} - Number of compounds
  per year
- src_python[:results output :session :dir (org-sbe
  container-dir-str)]{print(latex(P))} {{{results($P$)}}} - Initial balance
- src_python[:results output :session :dir (org-sbe
  container-dir-str)]{print(latex(r))} {{{results($r$)}}} - APR
- src_python[:results output :session :dir (org-sbe
  container-dir-str)]{print(latex(f))} {{{results($f$)}}} - Fee per compound

Using these base paramaters we can start with a foundation of compound interest
defined as follows.

#+NAME: compound-interest
#+HEADER: :exports none :results output
#+BEGIN_SRC python :dir (org-sbe container-dir-str) :session
  compound_interest = ( P * ( 1 + ( r / n ) ) ** n )
  compound_interest_latex = latex_center(latex(compound_interest))
  print(compound_interest_latex)
#+END_SRC

#+RESULTS: compound-interest
:
:  \begin{alignedat}{2}
:  P {\left(\frac{r}{n} + 1\right)}^{n}
:  \end{alignedat}

#+MACRO: compound-interest (eval (latex-display-wrap (org-sbe compound-interest)))

{{{compound-interest()}}}

While this is all well and good, we want to account for the fact that whenever
we want to "compound" our pending earnings, we need pay a fee to do so. With
this in mind we need to come up with an expression to account for each
penalization fee src_python[:results output :session  :dir (org-sbe
container-dir-str)]{print(latex(f))} {{{results(f)}}} over each compounding
instance src_python[:results output :session  :dir (org-sbe
container-dir-str)]{print(latex(n))} {{{results($n$)}}}.

To do this we will add on the idea of iterative penalties which is the summation
of fees across every compounding instance.

#+NAME: iterative-penalty
#+HEADER: :exports none :results output
#+BEGIN_SRC python :dir (org-sbe container-dir-str) :session
iterative_penalty = ( f * sum( (1 + (r / n))**i , i, 0, n-1, hold=True) )
print(latex_center(latex(iterative_penalty)))
#+END_SRC

#+RESULTS: iterative-penalty
:
:  \begin{alignedat}{2}
:  f {\sum_{i=0}^{n - 1} {\left(\frac{r}{n} + 1\right)}^{i}}
:  \end{alignedat}

#+MACRO: iterative-penalty (eval (latex-display-wrap (org-sbe iterative-penalty)))

{{{iterative-penalty()}}}

By subtracting the interative penalty fees from compound interest, we get the
following expression.

#+NAME: compound-interest-with-iterative-penalty-verbose
#+HEADER: :exports none :results output
#+BEGIN_SRC python :dir (org-sbe container-dir-str) :session
  compound_interest_with_iterative_penalty = compound_interest - iterative_penalty
  print(latex_center(latex(compound_interest_with_iterative_penalty)))
#+END_SRC

#+NAME: compound-interest-with-iterative-penalty-verbose
#+RESULTS: compound-interest-with-iterative-penalty-verbose
:
:  \begin{alignedat}{2}
:  P {\left(\frac{r}{n} + 1\right)}^{n} - f {\sum_{i=0}^{n - 1} {\left(\frac{r}{n} + 1\right)}^{i}}
:  \end{alignedat}

#+MACRO: compound-interest-with-iterative-penalty-verbose (eval (latex-display-wrap (org-sbe compound-interest-with-iterative-penalty-verbose)))

{{{compound-interest-with-iterative-penalty-verbose()}}}

Simplifying we can define the function $ciwip$ as the following expression

#+NAME: compound-interest-with-iterative-penalty-simple
#+HEADER: :exports none :results output
#+BEGIN_SRC python :dir (org-sbe container-dir-str) :session
  compound_interest_with_iterative_penalty = compound_interest - iterative_penalty.unhold()
  ciwip, c = function('ciwip'), function('c')
  print(latex_center(latex(ciwip(P,f,r,n) == compound_interest - iterative_penalty.unhold())))
#+END_SRC

#+RESULTS[92dcf708f6a8d7e37d1096957d942ffc9645a2ff]: compound-interest-with-iterative-penalty-simple
:
:  \begin{alignedat}{2}
:  {\rm ciwip}\left(P, f, r, n\right) = P {\left(\frac{r}{n} + 1\right)}^{n} - \frac{{\left(\left(\frac{r + {\left| 1.0 \, n + 0.01 \right|}}{{\left| 1.0 \, n + 0.01 \right|}}\right)^{n + 0.010000000000000009} {\left| 1.0 \, n + 0.01 \right|} - {\left| 1.0 \, n + 0.01 \right|}\right)} f}{r}
:  \end{alignedat}

#+MACRO: compound-interest-with-iterative-penalty-simple (eval (latex-display-wrap (org-sbe compound-interest-with-iterative-penalty-simple)))

{{{compound-interest-with-iterative-penalty-simple()}}}

* Visualization! :chart_with_upwards_trend:

Now that we have an expression to model an earning protocol, lets try to gain
some intuition about how they work with some visualizations! It seems most
reasonable to start with a 2D plot dependent on src_python[:results output
:session :dir (org-sbe container-dir-str)]{print(latex(n))} because it's the
only paramater that we can control once we put a deposit into an earning
protocol. Holding all the other parameters constant with some random values, we
get the following plot.

#+NAME: ciwip-func-def
#+HEADER: :exports none :results output
#+begin_src python :dir (org-sbe container-dir-str) :session
  def optimal_compound_interest_with_iterative_penalty(P_, f_, r_, astype=float):

      ## Formula for ciwip
      P, f, r, i, n = var("P f r i n")
      compound_interest = ( P * ( 1 + ( r / n ) ) ** n )
      iterative_penalty = ( f * sum( (1 + (r / n))**i , i, 0, n-1) )
      compound_interest_with_iterative_penalty = compound_interest - iterative_penalty

      ## Compute ciwip from params and minimize
      ciwip_min_ = -1.0 * compound_interest_with_iterative_penalty.substitute(P=P_, f=f_, r=r_)
      ciwip_min_result = sage.numerical.optimize.minimize(
          ciwip_min_,
          [1e-10],
          algorithm='bfgs',
          gradient=ciwip_min_.diff()
      )
      if astype == float:
          return ciwip_min_result[0]
      elif astype == int:
          if compound_interest_with_iterative_penalty.substitute(P=P_, f=f_, r=r_, n=floor(ciwip_min_result[0])) > \
              compound_interest_with_iterative_penalty.substitute(P=P_, f=f_, r=r_, n=ceil(ciwip_min_result[0])):
              return floor(ciwip_min_result[0])
          else:
              return ceil(ciwip_min_result[0])
      else:
          raise Exception(f"{astype} unsupported")
#+end_src

#+RESULTS: ciwip-func-def

#+NAME: compound-interest-with-iterative-penalty-plot
#+HEADER: :exports none :results output
#+BEGIN_SRC python :dir (org-sbe container-dir-str) :session
  from spb.backends.plotly import PB
  from spb import plot as spb_plot

  P, f, r, i, n = var("P f r i n")
  compound_interest = ( abs(P) * ( 1 + ( abs(r) / abs(n) ) ) ** abs(n) )
  iterative_penalty = ( (abs(f) * sum( (1 + (abs(r) / abs(n)))**i , i, 0, n-1) ) )
  compound_interest_with_iterative_penalty = compound_interest - iterative_penalty

  compound_interest_with_iterative_penalty = \
    abs(P)*(abs(r)/abs(n) + 1)**abs(n) - (((abs(r) + abs(n))/abs(n))**abs(n)*abs(n) - abs(n))*abs(f)/abs(r)

  title = "Compound interest with iterative penalty"
  filename = f'{title.lower().replace(" ","-")}-plot.png'
  params = {
      f: 2,
      r: 0.5,
      P: 100
  }
  params_by_str = {str(k): v for k,v in params.items()}
  params_tex_str = ' | '.join(f'{p}={v}' for p,v in params.items())
  taytay = compound_interest_with_iterative_penalty.taylor(n, (P*r)/(f*2), 1).subs(params)
  bb = solve((compound_interest_with_iterative_penalty==P), n)[0].rhs()
  pl = spb_plot(
      (compound_interest_with_iterative_penalty.subs(params), (n, 0, 40)),
      title=f"$\\text{{{title}}} \\\\ \\text{{{params_tex_str}}}$",
      show=False,
      use_latex=True,
      legend=False,
      theme="plotly",
      xlabel=f"${n}$",
      ylabel=f"${ciwip}$",
      ylim=(0, params[P] * 2),
      backend=PB
  )
  pl._update_layout()
  pl._fig.update_layout(
      title_x=0.09,
      margin=dict(
          l=70,
          r=50,
          b=70,
          t=100,
          pad = 4
      )
  )
  pl._process_series(pl._series)
  pl._fig.write_image(filename)
  print(f"Filename: {filename}")
#+END_SRC

#+RESULTS: compound-interest-with-iterative-penalty-plot
: Filename: compound-interest-with-iterative-penalty-plot.png

#+CAPTION: 2D view of compound interest with iterative penalties
[[./compound-interest-with-iterative-penalty-plot.png]]

With this 2D view we can now get a better understanding of what optimal
compounding really means.

The first intuition we can take away is that as we tend src_python[:results
output :session :dir (org-sbe container-dir-str)]{print(latex_right(latex(n),
latex(oo)))} {{{results($n \rightarrow +\infty$)}}} we see that our output value
tends towards negative infinity meaning we lose more than we are gaining (which
we don't want). However there is an inflection point at (around
src_python[:results output :session :dir (org-sbe
container-dir-str)]{print(latex(n==round(optimal_compound_interest_with_iterative_penalty(params_by_str['P'],
params_by_str['f'], params_by_str['r']), 2)))} {{{results($n = 2.45$)}}}) where
we make *more* than we lose. This means that by compounding at the right
frequency we can profit from the accrued rewards than the fee we need to pay to
claim them.

Now we can return to original question at the begginning: "how do we spend the
least too make the most?". The answer we can infer from this plot if "choose the
right src_python[:results output :session :dir (org-sbe
container-dir-str)]{print(latex(n))} {{{results($n$)}}}".

*Aside* - Something interesting to note is that as we tend src_python[:results
output :session :dir (org-sbe container-dir-str)]{print(latex_right(latex(n),
latex(oo)))} it looks like our function starts to becomes linear. We can prove
this if we take the limit of the derivative of our function. We can see it's
independent of src_python[:results output :session :dir (org-sbe
container-dir-str)]{print(latex(n))} {{{results($n$)}}} meaning that even though
compounding to infinity means we will keep losing, we will eventually lose at a
constant rate.

#+NAME: compound-interest-with-iterative-penalty-zero-limit-analysis
#+HEADER: :exports none :results output
#+BEGIN_SRC python :dir (org-sbe container-dir-str) :session
  print(
      latex_center(
          latex_lim(
              latex(
                  ciwip(P,f,r,n).derivative(n) == \
                  limit(compound_interest_with_iterative_penalty.derivative(n),n=oo)
              ),
              latex(n),
              latex(oo)
          )
      )
  )
#+END_SRC

#+RESULTS: compound-interest-with-iterative-penalty-zero-limit-analysis
:
:  \begin{alignedat}{2}
:  \lim\limits_{ n \rightarrow +\infty } \frac{\partial}{\partial n}{\rm ciwip}\left(P, f, r, n\right) = -\frac{f e^{r}}{r} + \frac{f}{r}
:  \end{alignedat}

#+MACRO: compound-interest-with-iterative-penalty-zero-limit-analysis (eval (latex-display-wrap (org-sbe compound-interest-with-iterative-penalty-zero-limit-analysis)))

{{{compound-interest-with-iterative-penalty-zero-limit-analysis()}}}

For the example above we used fixed parameters, but what if we changed them to
be higher or lower? How would our plot change? Would we still see the same
shape? To learn a little more about the shape of this function, lets unify all
the paramaters we can't control under some var src_python[:results output
:session :dir (org-sbe container-dir-str)]{print(latex(C))} {{{results($C$)}}}
and plot what we have left in 3D.

Doing so will give us the following expression:

#+NAME: homogenized-compound-interest-with-iterative-penalty
#+HEADER: :exports none :results output
#+BEGIN_SRC python :dir (org-sbe container-dir-str) :session
  C = var('C')
  homogenized_compound_interest_with_iterative_penalty = compound_interest_with_iterative_penalty.substitute(P=C, f=C, r=C)
  const_sympy = homogenized_compound_interest_with_iterative_penalty._sympy_()
  const_sympy_vars = {str(i): i for i in const_sympy.free_symbols}
  print(latex_center(latex(homogenized_compound_interest_with_iterative_penalty)))
#+END_SRC

#+RESULTS: homogenized-compound-interest-with-iterative-penalty
:
:  \begin{alignedat}{2}
:  C {\left(\frac{C}{{\left| n \right|}} + 1\right)}^{{\left| n \right|}} - \left(\frac{C + {\left| n \right|}}{{\left| n \right|}}\right)^{{\left| n \right|}} {\left| n \right|} + {\left| n \right|}
:  \end{alignedat}

#+MACRO: homogenized-compound-interest-with-iterative-penalty (eval (latex-display-wrap (org-sbe homogenized-compound-interest-with-iterative-penalty)))

{{{homogenized-compound-interest-with-iterative-penalty()}}}

#+NAME: homogenized-compound-interest-with-iterative-penalty-plot
#+HEADER: :exports none :results output
#+begin_src python :dir (org-sbe container-dir-str) :session
  import numpy as np
  import plotly.graph_objects as go
  from plotly.subplots import make_subplots

  def get_plane(M, v, xx, yy, zz):

      # M point contained by the plane
      # v direction included in plane (orthogonal to w=[0, 0, 1])
      x0, y0, _= M
      a, b, _= v

      if a == 0 and b != 0:
          Y, Z = np.meshgrid(yy, zz)
          X = x0*np.ones(Y.shape)
      elif a != 0 and b==0:
          X, Z = np.meshgrid(xx, zz)
          Y = y0*np.ones(X.shape)
      else:
          X, Z = np.meshgrid(xx, zz)
          Y = y0+b*(X-x0)/a
      return X, Y, Z


  # define xy mesh and z func output
  xx = np.linspace(2, 12, 50)
  yy = np.linspace(2, 12, 50)
  x,y = np.meshgrid(xx, yy)
  fff = sympy.lambdify((const_sympy_vars["n"], const_sympy_vars["C"]), const_sympy, "numpy")
  z = fff(x, y)
  zz = np.linspace(z.min(), z.max(), 50)

  M = [0, 11, 0]  # a point in the plane
  v = [1, 0, 0] # a direction contained in the plane
  X, Y, Z =  get_plane(M, v, xx, yy, zz)

  fig = make_subplots(
       rows=1, cols=1,
       horizontal_spacing=0.1)
  fig.add_trace(go.Surface(x=x,
                           y=y,
                           z=z,
                           colorscale="Viridis",
                           lighting=dict(diffuse=0.9),
                           showscale=False))
  fig.add_trace(go.Surface(x=X, y=Y, z=Z,
                           colorscale= [[0, "rgb(254, 254, 254)"],
                                        [1, "rgb(254, 254, 254)"]],
                           showscale=False,
                           lighting=dict(diffuse=0.9),
                           opacity=0.3))
  fig.update_layout(
      scene_camera=dict(
        eye=dict(x=2, y=2.5, z=2.3)
      ),
      margin=dict(t=0, r=0, l=0, b=0),
      width=600, height=600, yaxis = {"domain":  [0, 0.85]},
      scene = dict(
                    xaxis_title='n',
                    yaxis_title='C',
                    zaxis_title='$')
  )
  fig.update_xaxes(autorange="reversed")
  fig.update_xaxes(range=[12, 1])
  fig.update_scenes(xaxis_autorange="reversed")
  fig.update_scenes(yaxis_autorange="reversed")
  fig.write_image("homogenized-compound-interest-with-iterative-penalty-plot.png")
  print("done!")
#+end_src

#+RESULTS: homogenized-compound-interest-with-iterative-penalty-plot
: done!

#+CAPTION: A surface 3d plot of homogenized compound interest with iterative penalties
[[./homogenized-compound-interest-with-iterative-penalty-plot.png]]

The interesting thing we can observe is that if we hold the variables we can't
control constant (via src_python[:results output :session :dir (org-sbe
container-dir-str)]{print(latex(C))} {{{results($C$)}}}) and represent some
choice src_python[:results output :session :dir (org-sbe
container-dir-str)]{print(latex(C))} by slicing the space with a plane (shown by
the slightly opaque vertical plane), the corresponding cross section is the
space of possibile results of our balance as a consequence of choosing some
src_python[:results output :session :dir (org-sbe
container-dir-str)]{print(latex(n))}. Looking closely, there seems to be a
similar shape between the intersection and the 2D plot, and if we slide the
opaque plane up and down the src_python[:results output :session :dir (org-sbe
container-dir-str)]{print(latex(C))} axis, the shape seems consistant. However
this empirical observation doesn't prove anything. Instead let's define a narrow
problem we want to solve for, and prove a property about the problem.

* Optimality! â›°

We showed in the previous section that when we chose some fixed parameters for
our src_python[:results output :session :dir (org-sbe
container-dir-str)]{print(latex(ciwip()))} {{{results(${\rm
ciwip}\left(\right)$)}}} function, there was an optimal src_python[:results
output :session :dir (org-sbe container-dir-str)]{print(latex(n))} that enables
us to earn more than we lose. This is obviously an ideal case which we want to
happen all the time! Unfortunately, in reality, our "fixed" parameters aren't so
"fixed". What we really want to know is for any reasonable set of parameters,
can we find an optimal value that is greater than our initial balance

In order to find out if this function is truley convex, we can leverage Jensen's
inequality to check if the inequality is true.

#+NAME: jensins-inequality
#+HEADER: :exports none :results output
#+BEGIN_SRC python :dir (org-sbe container-dir-str) :session
  def jensins_inequality(func=None, a=None, b=None):
      if func is None:
          func = function("f")
      if a is None:
          a = var("x_1")
      if b is None:
          b = var("x_2")

      lam = var('lam', latex_name="\\alpha")
      return \
          func(lam * a + (1 - lam) * b) \
          <= \
          lam * func(a) + (1 - lam) * func(b)

  print(
      latex_center(
          latex(jensins_inequality())
      )
  )
#+END_SRC

#+RESULTS: jensins-inequality
:
:  \begin{alignedat}{2}
:  f\left({\alpha} x_{1} - {\left({\alpha} - 1\right)} x_{2}\right) \leq {\alpha} f\left(x_{1}\right) - {\left({\alpha} - 1\right)} f\left(x_{2}\right)
:  \end{alignedat}

#+MACRO: jensins-inequality (eval (latex-display-wrap (org-sbe jensins-inequality)))

{{{jensins-inequality()}}}

#+NAME: tmp1
#+HEADER: :exports none :results output
#+BEGIN_SRC python :dir (org-sbe container-dir-str) :session
  '''
  s = {
      f: 3,
      r: 1,
      P: 70
  }
  a = 0
  b = solve((compound_interest_with_iterative_penalty==P), n)[0].rhs()
  ji = jensins_inequality(compound_interest_with_iterative_penalty, a, b)

  second_diff = compound_interest_with_iterative_penalty.diff(n).diff(n)
  ji = jensins_inequality(homogenized_compound_interest_with_iterative_penalty, a, b.substitute(P=C, f=C, r=C))
  latex(ji.lhs() - ji.rhs() >= 0)

  # ji = jensins_inequality(homogenized_compound_interest_with_iterative_penalty, a, b)
  P, f, r, i, nn = var("P f r i n")
  n = nn + 0.01
  compound_interest = ( abs(P) * ( 1 + ( abs(r) / abs(n) ) ) ** abs(n) )
  iterative_penalty = ( (abs(f) * sum( (1 + (abs(r) / abs(n)))**i , i, 0, n-1) ) )
  compound_interest_with_iterative_penalty = compound_interest - iterative_penalty
  '''

  '''
  from sympy import solveset, S, Interval
  solveset(ji.lhs() - ji.rhs() >= 0, (P, f, r, n, var('lam', latex_name="\\alpha")), Interval(0, oo))
  ji.lhs() - ji.rhs() >= 0
  '''

  '''
  import cvxpy as cp
  n = cp.Variable(pos=True)
  P = cp.Parameter(pos=True)
  f = cp.Parameter(pos=True)
  r = cp.Parameter(pos=True)
  P*(r/n + 1)**n - (n*((n + r)/n)**n - n)*f/r
  '''
#+END_SRC

#+RESULTS: tmp1
: /home/sage/sage/local/bin/ipython:8: DeprecationWarning: Substitution using function-call syntax and unnamed arguments is deprecated and will be removed from a future release of Sage; you can use named arguments instead, like EXPR(x=..., y=...)
: See http://trac.sagemath.org/5930 for details.
:   if __name__ == '__main__':
: /home/sage/sage/local/bin/ipython:11: DeprecationWarning: Substitution using function-call syntax and unnamed arguments is deprecated and will be removed from a future release of Sage; you can use named arguments instead, like EXPR(x=..., y=...)
: See http://trac.sagemath.org/5930 for details.
:   load_entry_point('ipython==5.8.0', 'console_scripts', 'ipython')()


#+NAME: tmp2
#+HEADER: :exports none :results output
#+BEGIN_SRC python :dir (org-sbe container-dir-str) :session
  s = {
      f: 3,
      r: 1,
      P: 70
  }
  #a = 0
  #b = solve((compound_interest_with_iterative_penalty==P), n)[0].rhs()
  #ji = jensins_inequality(compound_interest_with_iterative_penalty, a, b)
  # print(
  #     latex_center(
  #         latex(ji)
  #     )
  # )

  # filename = '/mnt/h.png'
  # n = var('n')
  # P,f, r, i = var("P f r i")
  # compound_interest = ( P * ( 1 + ( r / n ) ) ** n )
  # iterative_penalty = ( f * sum( (1 + (r / n))**i , i, 0, n-1) )
  # compound_interest_with_iterative_penalty = compound_interest - iterative_penalty
  # s = {
  #     f: 3,
  #     r: 1,
  #     P: 70
  # }
  #g = Graphics()
  #print((ji.lhs() - ji.rhs()).simplify())
  #g += plot((ji.lhs() - ji.rhs()).subs({P:1}), (0, 1.1))
  #g.save(filename=filename)
  #print(f"Filename: {filename}")

  #beep = c(lam * x_p + (1 - lam) * y_p) <= lam * c(x_p) + (1 - lam) * c(y_p)
  #print(beep)
  #assume(n, 'real')
  #print(solve(simplify(cc.subs({n: (1 - lam) * (70/3.0)}).subs(s) <= (lam * -P + (1 - lam) * -P).subs(s)), lam, domain='real'))
  #asdfasdf = simplify(cc.subs({n: (1 - lam) * (70/3.0)}).subs(s) - (lam * -P + (1 - lam) * -P).subs(s))
  #print(asdfasdf)
  #filename = '/mnt/g.png'
  #g = Graphics()
  #g += plot(asdfasdf, (lam, 0, 1))
  #g.save(filename=filename)
  #print(f"Filename: {filename}")
  #print(simplify(cc.subs({n: (1 - lam) * (70/3.0)}).subs(s) <= (lam * -P + (1 - lam) * -P).subs(s)).subs({lam: 0}))
  #print(simplify(cc.subs({n: (1 - lam) * (70/3.0)}).subs(s) <= (lam * -P + (1 - lam) * -P).subs(s)).subs({lam: 0.5}))
  #print(simplify(cc.subs({n: (1 - lam) * (70/3.0)}).subs(s) <= (lam * -P + (1 - lam) * -P).subs(s)).subs({lam: 0.999}))
#+END_SRC

#+RESULTS: tmp2
: /home/sage/sage/local/bin/ipython:12: DeprecationWarning:
:
: Substitution using function-call syntax and unnamed arguments is deprecated and will be removed from a future release of Sage; you can use named arguments instead, like EXPR(x=..., y=...)
: See http://trac.sagemath.org/5930 for details.
:
: -3*lam*x_1 + 3*(lam - 1)*x_2 + 3*(lam*x_1 - (lam - 1)*x_2)*((lam*x_1 - (lam - 1)*x_2 + 1)/(lam*x_1 - (lam - 1)*x_2))^(lam*x_1 - (lam - 1)*x_2) - 70*(1/(lam*x_1 - (lam - 1)*x_2) + 1)^(lam*x_1 - (lam - 1)*x_2) >= -(3*x_2*((x_2 + 1)/x_2)^x_2 - 3*x_2 - 70*(1/x_2 + 1)^x_2)*(lam - 1) + (3*x_1*((x_1 + 1)/x_1)^x_1 - 3*x_1 - 70*(1/x_1 + 1)^x_1)*lam

#+MACRO: tmp2 (eval (latex-display-wrap (org-sbe tmp2)))

Now it might not look like it, but graphing both sides of this inequality shows
that this expression is true for $0 \lt \alpha \lt 1$ meaning that this function
IS convex.

* Environment teardown                                             :noexport:

#+HEADER: :exports none
#+begin_src sh :var NAME=(org-table-get-constant "container_name") :var SHUTDOWN=(org-table-get-constant "shutdown-env")
# [[ $SHUTDOWN ]] && podman kill $NAME; podman rm $NAME
#+end_src

#+RESULTS:
| compounder                                                       |
| 514dc2da37e88051d3bd8417bb6a9dc5879c43f60c53301fe2bc1f594c33d587 |
