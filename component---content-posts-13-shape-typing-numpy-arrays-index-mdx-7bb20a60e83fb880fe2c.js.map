{"version":3,"file":"component---content-posts-13-shape-typing-numpy-arrays-index-mdx-7bb20a60e83fb880fe2c.js","mappings":"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","sources":["webpack://TAOA/./content/posts/13_Shape_typing_numpy_arrays/index.mdx"],"sourcesContent":["import * as React from 'react'\n  /* @jsx mdx */\nimport { mdx } from '@mdx-js/react';\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\n\nimport DefaultLayout from \"/home/node/work/src/templates/post.template.tsx\";\nexport const _frontmatter = {};\nconst layoutProps = {\n  _frontmatter\n};\nconst MDXLayout = DefaultLayout;\nexport default function MDXContent({\n  components,\n  ...props\n}) {\n  return <MDXLayout {...layoutProps} {...props} components={components} mdxType=\"MDXLayout\">\n\n\n    <p>{`When doing any sort of tensor/array computation in python (via `}<inlineCode parentName=\"p\">{`numpy`}</inlineCode>{`,\n`}<inlineCode parentName=\"p\">{`pytorch`}</inlineCode>{`, `}<inlineCode parentName=\"p\">{`jax`}</inlineCode>{`, or other`}{`>`}{`>`}{`), it's more frequent than not to encounter shape\nerrors like the one below`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-python\"\n      }}>{`import numpy as np\n\nsize1 = (2,3)\nsize2 = (4,3)\n\nM1 = np.random.random(size=size1)\nM2 = np.random.random(size=size2)\n\ntry:\n    print(np.dot(M1,M2))\nexcept Exception as e:\n    print(e)\n`}</code></pre>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-text\"\n      }}>{`shapes (2,3) and (4,3) not aligned: 3 (dim 1) != 4 (dim 0)\n`}</code></pre>\n    <p>{`And most of the time, these kind of errors boil down to something like\naccidentally forgetting to do a reshape or transpose like so.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-python\"\n      }}>{`import numpy as np\n\nsize1 = (2,3)\nsize2 = (4,3)\n\nM1 = np.random.random(size=size1)\nM2 = np.random.random(size=size2).T\n\ntry:\n    print(np.dot(M1,M2))\nexcept Exception as e:\n    print(e)\n`}</code></pre>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-text\"\n      }}>{`[[0.30107944 0.77536851 1.09367428 0.40458726]\n [0.36731406 1.01442791 1.28123555 0.51842414]]\n`}</code></pre>\n    <p>{`And while this is a mild case, shape bugs like these become more frequent as\noperations grow more complex and as more dimensions are involved.`}</p>\n    <p>{`Here's a slightly more complex example of a `}<inlineCode parentName=\"p\">{`Linear`}</inlineCode>{` implementation in `}<inlineCode parentName=\"p\">{`numpy`}</inlineCode>{`\nwith a subtle shape bug.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-python\"\n      }}>{`def Linear(A, x, b):\n    \"\"\"\n    Takes matrix A (m x n) times a vector x (n x 1) and\n    adds a bias. The resulting ndarray is then ravelled\n    into a vector of size (m).\n    \"\"\"\n    Ax = np.dot(A, x)\n    Axb = np.add(Ax, b)\n    return np.ravel(Axb)\n\nA = np.random.random(size=(4,4))\nx = np.random.random(size=(4,1))\nb = np.random.random(size=(4))\n\nresult = Linear(A, x, b)\nprint(result)\nprint(result.shape)\n`}</code></pre>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-text\"\n      }}>{`[2.0367838  1.63654023 2.02552241 1.38342291 2.44376582 2.04352225\n 2.43250443 1.79040493 2.65987874 2.25963517 2.64861735 2.00651785\n 2.44294654 2.04270297 2.43168515 1.78958565]\n(16,)\n`}</code></pre>\n    <p>{`The docstring of `}<inlineCode parentName=\"p\">{`Linear`}</inlineCode>{` clearly says the result should be size `}<inlineCode parentName=\"p\">{`m`}</inlineCode>{` (or\n`}<inlineCode parentName=\"p\">{`4`}</inlineCode>{`). But why then did we end up with a vector of size `}<inlineCode parentName=\"p\">{`16`}</inlineCode>{`? If we dig into\neach function we will eventually find that our problem is in how `}<inlineCode parentName=\"p\">{`numpy`}</inlineCode>{`\nhandles an `}<inlineCode parentName=\"p\">{`ndarray`}</inlineCode>{` of a different shape.`}</p>\n    <p>{`If we break down `}<inlineCode parentName=\"p\">{`Linear`}</inlineCode>{`, after `}<inlineCode parentName=\"p\">{`np.dot`}</inlineCode>{` we have an `}<inlineCode parentName=\"p\">{`ndarray`}</inlineCode>{` of shape\n`}<inlineCode parentName=\"p\">{`(4,1)`}</inlineCode>{` of which we do `}<inlineCode parentName=\"p\">{`np.add`}</inlineCode>{` with a vector of shape `}<inlineCode parentName=\"p\">{`(4)`}</inlineCode>{`. And here lies\nour bug. We might naturally think that `}<inlineCode parentName=\"p\">{`np.add`}</inlineCode>{` will do this addition element\nwise, but instead we fell into an `}<a parentName=\"p\" {...{\n        \"href\": \"https://numpy.org/doc/stable/user/basics.broadcasting.html#broadcastable-arrays\"\n      }}>{`array broadcasting`}</a>{` trap. Array broadcasting\nare sets of rules `}<inlineCode parentName=\"p\">{`numpy`}</inlineCode>{` uses to determine how to do arithmetic on different\nshaped `}<inlineCode parentName=\"p\">{`ndarrays`}</inlineCode>{`. So instead of doing our computation element wise, `}<inlineCode parentName=\"p\">{`numpy`}</inlineCode>{`\ninterprets this as doing a broadcast operation of addition, resulting in a\n`}<inlineCode parentName=\"p\">{`(4,4)`}</inlineCode>{` matrix, which subsequently gets \"raveled\" into a size `}<inlineCode parentName=\"p\">{`16`}</inlineCode>{` vector.`}</p>\n    <p>{`Now to fix this is easy, we just need to initialize our `}<inlineCode parentName=\"p\">{`b`}</inlineCode>{` variable to be of\nshape `}<inlineCode parentName=\"p\">{`(4,1)`}</inlineCode>{` so `}<inlineCode parentName=\"p\">{`numpy`}</inlineCode>{` will interpret the `}<inlineCode parentName=\"p\">{`np.add`}</inlineCode>{` as an element wise\naddition.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-python\"\n      }}>{`def Linear(A, x, b):\n    \"\"\"\n    Takes matrix A (m x n) times a vector x (n x 1) and\n    adds a bias. The resulting ndarray is then ravelled\n    into a vector of size (m).\n    \"\"\"\n    Ax = np.dot(A, x)\n    Axb = np.add(Ax, b)\n    return np.ravel(Axb)\n\nA = np.random.random(size=(4,4))\nx = np.random.random(size=(4,1))\nb = np.random.random(size=(4,1))\n\nresult = Linear(A, x, b)\nprint(result)\nprint(result.shape)\n`}</code></pre>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-text\"\n      }}>{`[1.72493875 0.91784843 1.57265948 1.49376213]\n(4,)\n`}</code></pre>\n    <p>{`We've solved the problem, but how can we be smarter to prevent this error from\nhappening again?`}</p>\n    <h2 {...{\n      \"id\": \"existing-ways-to-stop-shape-bugs\"\n    }}>{`Existing ways to stop shape bugs`}</h2>\n    <p>{`The simplest way we can try to stop this shape bug is with good docs. Ideally\nwe should always have good docs, but we can make it a point to include what\nthe shape expectations are like so:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-python\"\n      }}>{`def Linear(A, x, b):\n    \"\"\"\n    Args:\n        A: ndarray of shape (M x N)\n        x: ndarray of shape (N x 1)\n        b: ndarray of shape (M x 1)\n\n    Returns:\n        Linear output ndarray of shape (M)\n    \"\"\"\n    Ax = np.dot(A, x) # Shape (M x 1)\n    Axb = np.add(Ax, b) # (M x 1) + (M x 1)\n    return np.ravel(Axb) # Shape (M)\n`}</code></pre>\n    <p>{`Now while informative, nothing is preventing us from encountering the same bug\nagain. The only benefit this gives us, is making the debugging process a\nbit easier.`}</p>\n    <p>{`We can do better.`}</p>\n    <p>{`Another approach in addition to good docs that's more of a preventative action\nis to use assertions. By sprinkling `}<inlineCode parentName=\"p\">{`assert`}</inlineCode>{` throughout `}<inlineCode parentName=\"p\">{`Linear`}</inlineCode>{` with an\ninformative error message, we can \"fail early\" and start debugging like so:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-python\"\n      }}>{`def Linear(A, x, b):\n    \"\"\"\n    Args:\n        A: ndarray of shape (M x N)\n        x: ndarray of shape (N x 1)\n        b: ndarray of shape (M x 1)\n\n    Returns:\n        Linear output ndarray of shape (M)\n    \"\"\"\n    assert len(A.shape) == 2, f\"A must be of dim 2, not {len(A.shape)}\"\n    Am, An = A.shape\n\n    assert x.shape == (An, 1), f\"X must be shape ({An}, 1) to do dot\"\n    Ax = np.dot(A, x) # Shape (M x 1)\n\n    assert b.shape == (Am, 1), f\"Bias term must be shape ({Am}, 1)\"\n    result = np.add(Ax, b) # (M x 1) + (M x 1)\n\n    ravel_result = np.ravel(result)\n    assert ravel_result.shape == (Am,), f\"Uh oh, ravel result is shape {ravel_result.shape} and not {(Am,)}\"\n    return ravel_result\n`}</code></pre>\n    <p>{`At every step of this function we do an `}<inlineCode parentName=\"p\">{`assert`}</inlineCode>{` to make sure all the\n`}<inlineCode parentName=\"p\">{`ndarray`}</inlineCode>{` shapes are what we expect.`}</p>\n    <p>{`As a result `}<inlineCode parentName=\"p\">{`Linear`}</inlineCode>{` is a bit \"safer\". But compared to what we had originally,\nthis approach is much less readable. We also inherit some of the baggage that\ncomes with runtime error checking like:`}</p>\n    <ul>\n      <li parentName=\"ul\">\n        <p parentName=\"li\"><strong parentName=\"p\">{`Incomplete checking`}</strong>{`: Have we checked all expected shape failure modes?`}</p>\n      </li>\n      <li parentName=\"ul\">\n        <p parentName=\"li\"><strong parentName=\"p\">{`Slow debugging cycles`}</strong>{`: How many refactor-`}{`>`}{`run cycles will we have to do\npass the checks?`}</p>\n      </li>\n      <li parentName=\"ul\">\n        <p parentName=\"li\"><strong parentName=\"p\">{`Additional testing`}</strong>{`: Do we have to update our tests cover our runtime error\nchecks?`}</p>\n      </li>\n    </ul>\n    <p>{`Overall runtime error checking is not a bad thing. In most cases it's very\nnecessary! But when it comes to shape errors, we can leverage an additional\napproach, static type checking.`}</p>\n    <p>{`Even though `}<inlineCode parentName=\"p\">{`python`}</inlineCode>{` is a dynamically typed language, in `}<inlineCode parentName=\"p\">{`python>=3.5`}</inlineCode>{` the\n`}<inlineCode parentName=\"p\">{`typing`}</inlineCode>{` module was introduced to enable static type checkers to validate type\nhinted `}<inlineCode parentName=\"p\">{`python`}</inlineCode>{` code. (See `}<a parentName=\"p\" {...{\n        \"href\": \"https://www.youtube.com/watch?v=2wDvzy6Hgxg\"\n      }}>{`this video`}</a>{` for more details)`}</p>\n    <p>{`Over time many third party libraries (like `}<inlineCode parentName=\"p\">{`numpy`}</inlineCode>{`) have started to type hint\ntheir codebases which we can use to our benefit.`}</p>\n    <p>{`In order to help us prevent shape errors, let's see what typing capabilities\nexist in `}<inlineCode parentName=\"p\">{`numpy`}</inlineCode>{`.`}</p>\n    <h2 {...{\n      \"id\": \"dtype-typing-numpy-arrays\"\n    }}><inlineCode parentName=\"h2\">{`dtype`}</inlineCode>{` typing `}<inlineCode parentName=\"h2\">{`numpy`}</inlineCode>{` arrays`}</h2>\n    <p>{`As of writing this post, `}<inlineCode parentName=\"p\">{`numpy==v1.24.2`}</inlineCode>{` only supports typing on an\n`}<inlineCode parentName=\"p\">{`ndarray`}</inlineCode>{`'s `}<inlineCode parentName=\"p\">{`dtype`}</inlineCode>{` (`}<inlineCode parentName=\"p\">{`uint8`}</inlineCode>{`, `}<inlineCode parentName=\"p\">{`float64`}</inlineCode>{`, etc.).`}</p>\n    <p>{`Using `}<inlineCode parentName=\"p\">{`numpy`}</inlineCode>{`'s existing type hinting tooling, here's how we would include\n`}<inlineCode parentName=\"p\">{`dtype`}</inlineCode>{` type information to our `}<inlineCode parentName=\"p\">{`Linear`}</inlineCode>{` example (note: there is an\nintentional type error)`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-python\"\n      }}>{`from typing import TypeVar\n\nimport numpy as np\nfrom numpy.typing import NDArray\n\nGenericType = TypeVar(\"GenericType\", bound=np.generic)\n\n\ndef Linear(\n        A: NDArray[GenericType],\n        x: NDArray[GenericType],\n        b: NDArray[GenericType],\n) -> NDArray[GenericType]:\n    \"\"\"\n    Args:\n        A: ndarray of shape (M x N)\n        x: ndarray of shape (N x 1)\n        b: ndarray of shape (M x 1)\n\n    Returns:\n\n        Linear output ndarray of shape (M)\n    \"\"\"\n    assert len(A.shape) == 2, f\"A must be of dim 2, not {len(A.shape)}\"\n    Am, An = A.shape\n\n    assert x.shape == (An, 1), f\"X must be shape ({An}, 1) to do dot\"\n    Ax: NDArray[GenericType] = np.dot(A, x)  # Shape (M x 1)\n\n    assert b.shape == (Am, 1), f\"Bias term must be shape ({Am}, 1)\"\n    result: NDArray[GenericType] = np.add(Ax, b)  # (M x 1) + (M x 1)\n\n    ravel_result: NDArray[GenericType] = np.ravel(result)\n    assert ravel_result.shape == (Am,), f\"Uh oh, ravel result is shape {ravel_result.shape} and not {(Am,)}\"\n    return ravel_result\n\n\nA: NDArray[np.float64] = np.random.standard_normal(size=(10, 10))\nx: NDArray[np.float64] = np.random.standard_normal(size=(10, 1))\nb: NDArray[np.float32] = np.random.standard_normal(size=(10, 1))\ny: NDArray[np.float64] = Linear(A, x, b)\nprint(y)\nprint(y.dtype)\n`}</code></pre>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-text\"\n      }}>{`[-0.38677273 -2.68384527  1.19333451 -0.18736847 -3.43392021 -1.51889879\n  5.6047523   3.97918204  2.54240063  1.95581106]\nfloat64\n`}</code></pre>\n    <p>{`Even though this code is \"runnable\" and doesn't produce an error, a type\nchecker like `}<inlineCode parentName=\"p\">{`pyright`}</inlineCode>{` tells us a different story.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-bash\"\n      }}>{`pyright linear_bad_typing.py\n`}</code></pre>\n    <p><inlineCode parentName=\"p\">{`pyright`}</inlineCode>{` has noticed that when we create our `}<inlineCode parentName=\"p\">{`b`}</inlineCode>{` variable, we gave it a\n`}<inlineCode parentName=\"p\">{`dtype`}</inlineCode>{` type that is incompatible with `}<inlineCode parentName=\"p\">{`np.random.standard_normal`}</inlineCode>{`.`}</p>\n    <p>{`Now we know to adjust the type hint of `}<inlineCode parentName=\"p\">{`b`}</inlineCode>{` to be in line with the `}<inlineCode parentName=\"p\">{`dtype`}</inlineCode>{` that\nis expected of `}<inlineCode parentName=\"p\">{`np.random.standard_normal`}</inlineCode>{` (`}<inlineCode parentName=\"p\">{`NDArray[np.float64]`}</inlineCode>{`).`}</p>\n    <h2 {...{\n      \"id\": \"shape-typing-numpy-arrays\"\n    }}>{`Shape typing `}<inlineCode parentName=\"h2\">{`numpy`}</inlineCode>{` arrays`}</h2>\n    <p>{`While `}<inlineCode parentName=\"p\">{`dtype`}</inlineCode>{` typing is great, it's not the most useful for preventing shape\nerrors (like from our original example).`}</p>\n    <p>{`Ideally it would be great if in addition to a `}<inlineCode parentName=\"p\">{`dtype`}</inlineCode>{` type, we can also\ninclude information about an `}<inlineCode parentName=\"p\">{`ndarray`}</inlineCode>{`'s shape to do shape typing.`}</p>\n    <p>{`Shape typing is a technique used to annotate information about the\ndimensionality and size of an array. In the context of `}<inlineCode parentName=\"p\">{`numpy`}</inlineCode>{` and the\n`}<inlineCode parentName=\"p\">{`python`}</inlineCode>{` type hinting system, we can use shape typing catch shape errors\nbefore runtime.`}</p>\n    <blockquote>\n      <p parentName=\"blockquote\">{`For more information about shape typing checkout `}<a parentName=\"p\" {...{\n          \"href\": \"https://docs.google.com/document/d/1But-hjet8-djv519HEKvBN6Ik2lW3yu0ojZo6pG9osY/edit#heading=h.aw3bt3fg1s2w\"\n        }}>{`this google doc on a shape\ntyping syntax proposal`}</a>{` by Matthew Rahtz, JÃ¶rg Bornschein, Vlad Mikulik, Tim\nHarley, Matthew Willson, Dimitrios Vytiniotis, Sergei Lebedev, Adam Paszke.`}</p>\n    </blockquote>\n    <p>{`As we've seen, `}<inlineCode parentName=\"p\">{`numpy`}</inlineCode>{`'s `}<inlineCode parentName=\"p\">{`NDArray`}</inlineCode>{` currently only supports `}<inlineCode parentName=\"p\">{`dtype`}</inlineCode>{` typing and\ndoesn't have any of this kind of shape typing ability. But why is that? If we\ndig into the definition of the `}<inlineCode parentName=\"p\">{`NDArray`}</inlineCode>{` type:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-python\"\n      }}>{`ScalarType = TypeVar(\"ScalarType\", bound=np.generic, covariant=True)\n\nif TYPE_CHECKING or sys.version_info >= (3, 9):\n    _DType = np.dtype[ScalarType]\n    NDArray = np.ndarray[Any, np.dtype[ScalarType]]\nelse:\n    _DType = _GenericAlias(np.dtype, (ScalarType,))\n    NDArray = _GenericAlias(np.ndarray, (Any, _DType))\n`}</code></pre>\n    <p>{`And follow the definition of `}<inlineCode parentName=\"p\">{`np.ndarray`}</inlineCode>{` ...`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-python\"\n      }}>{`class ndarray(_ArrayOrScalarCommon, Generic[_ShapeType, _DType_co]):\n`}</code></pre>\n    <p>{`We can see that it looks like `}<inlineCode parentName=\"p\">{`numpy`}</inlineCode>{` uses a `}<inlineCode parentName=\"p\">{`Shape`}</inlineCode>{` type already! But\nunfortunately if we look at the definition for this ...`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-python\"\n      }}>{`# TODO: Set the \\`bound\\` to something more suitable once we\n# have proper shape support\n_ShapeType = TypeVar(\"_ShapeType\", bound=Any)\n_ShapeType2 = TypeVar(\"_ShapeType2\", bound=Any)\n`}</code></pre>\n    <p>{`ðŸ˜­ Looks like we're stuck with `}<inlineCode parentName=\"p\">{`Any`}</inlineCode>{` which doesn't add any useful shape\ninformation on our types.`}</p>\n    <p>{`Luckily for us, we don't have to wait for shape support in `}<inlineCode parentName=\"p\">{`numpy`}</inlineCode>{`. `}<a parentName=\"p\" {...{\n        \"href\": \"https://peps.python.org/pep-0646/\"\n      }}>{`PEP 646`}</a>{` has\nthe base foundation for shape typing and has already been accepted into python\n`}<inlineCode parentName=\"p\">{`3.11`}</inlineCode>{`! And it's supported by `}<inlineCode parentName=\"p\">{`pyright`}</inlineCode>{`! Theoretically these two things give\nus most of the ingredients to do basic shape typing.`}</p>\n    <p>{`Now this blog post isn't about the details of `}<a parentName=\"p\" {...{\n        \"href\": \"https://peps.python.org/pep-0646/\"\n      }}>{`PEP 646`}</a>{` or variadic\ngenerics. But the rest of this post will assume you know the basics of how\nthey work.`}</p>\n    <p>{`In order to add rudimentary shape typing to `}<inlineCode parentName=\"p\">{`numpy`}</inlineCode>{` we can simply change the\n`}<inlineCode parentName=\"p\">{`Any`}</inlineCode>{` type in the `}<inlineCode parentName=\"p\">{`NDArray`}</inlineCode>{` type definition to an unpacked variadic generic\nlike so:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-python\"\n      }}>{`ScalarType = TypeVar(\"ScalarType\", bound=np.generic, covariant=True)\nShape = TypeVarTuple(\"Shape\")\n\nif TYPE_CHECKING or sys.version_info >= (3, 9):\n    _DType = np.dtype[ScalarType]\n    NDArray = np.ndarray[*Shape, np.dtype[ScalarType]]\nelse:\n    _DType = _GenericAlias(np.dtype, (ScalarType,))\n    NDArray = _GenericAlias(np.ndarray, (Any, _DType))\n`}</code></pre>\n    <p>{`Doing so allows us to fill in a `}<inlineCode parentName=\"p\">{`Tuple`}</inlineCode>{` based type (indicating shape) in an\n`}<inlineCode parentName=\"p\">{`NDArray`}</inlineCode>{` alongside a `}<inlineCode parentName=\"p\">{`dtype`}</inlineCode>{` type. And shape typing with `}<inlineCode parentName=\"p\">{`Tuple`}</inlineCode>{`'s enables us\ndefine function overloads which describe to a type checker the possible ways a\nfunction can change the shape of an `}<inlineCode parentName=\"p\">{`NDArray`}</inlineCode>{`.`}</p>\n    <p>{`Let's look at an example of using these concepts to type a wrapper function\nfor `}<inlineCode parentName=\"p\">{`np.random.standard_normal`}</inlineCode>{` from our `}<inlineCode parentName=\"p\">{`Linear`}</inlineCode>{` example with an intentional\ntype error:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-python\"\n      }}>{`import numpy as np\nfrom numpy.typing import NDArray\nfrom typing import Tuple, TypeVar, Literal\n\n# Generic dimension sizes types\nT1 = TypeVar(\"T1\", bound=int)\nT2 = TypeVar(\"T2\", bound=int)\nT3 = TypeVar(\"T3\", bound=int)\n\n# Dimension types represented as typles\nShape = Tuple\nShape1D = Shape[T1]\nShape2D = Shape[T1, T2]\nShape3D = Shape[T1, T2, T3]\nShapeND = Shape[T1, ...]\nShapeNDType = TypeVar(\"ShapeNDType\", bound=ShapeND)\n\ndef rand_normal_matrix(shape: ShapeNDType) -> NDArray[ShapeNDType, np.float64]:\n    \"\"\"Return a random ND normal matrix.\"\"\"\n    return np.random.standard_normal(size=shape)\n\n# Yay correctly typed 2x2x2 cube!\nTWO = Literal[2]\ntwo_by_two_by_two: NDArray[Shape3D[TWO, TWO, TWO], np.float64] = rand_normal_matrix((2,2,2))\nprint(two_by_two_by_two)\n\nFOUR = Literal[4]\n\n# Uh oh the shapes won't match!\nfour_by_four: NDArray[Shape2D[FOUR, FOUR], np.float64] = rand_normal_matrix((3,3))\nprint(four_by_four)\n`}</code></pre>\n    <p>{`Notice here there are no `}<inlineCode parentName=\"p\">{`assert`}</inlineCode>{` statements. And instead of several comments\nabout shape, we indicate shape in the type hint.`}</p>\n    <p>{`Now while this code is \"runnable\", `}<inlineCode parentName=\"p\">{`pyright`}</inlineCode>{` will tell us something else:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-bash\"\n      }}>{`py -m pyright bad_shape_typing.py --lib\n`}</code></pre>\n    <p><inlineCode parentName=\"p\">{`pyright`}</inlineCode>{` is telling us we've incorrectly typed `}<inlineCode parentName=\"p\">{`four_by_four`}</inlineCode>{` and that it's\nincompatible with a `}<inlineCode parentName=\"p\">{`3x3`}</inlineCode>{` shape. Now we know we need to go back and fix the\ntype to what a type checker should expect.`}</p>\n    <p>{`Huzzah shape typing!!`}</p>\n    <h2 {...{\n      \"id\": \"moar-numpy-shape-typing\"\n    }}>{`Moar `}<inlineCode parentName=\"h2\">{`numpy`}</inlineCode>{` shape typing!`}</h2>\n    <p>{`Now that we have shape typed one function, let's step it up a notch. Let's try\ntyping each `}<inlineCode parentName=\"p\">{`numpy`}</inlineCode>{` function in our `}<inlineCode parentName=\"p\">{`Linear`}</inlineCode>{` example to include shape\ntypes. We've already typed `}<inlineCode parentName=\"p\">{`np.random.standard_normal`}</inlineCode>{`, so next let's do\n`}<inlineCode parentName=\"p\">{`np.dot`}</inlineCode>{`.`}</p>\n    <p>{`If we look at the `}<a parentName=\"p\" {...{\n        \"href\": \"https://numpy.org/doc/stable/reference/generated/numpy.dot.html\"\n      }}>{`docs for `}<inlineCode parentName=\"a\">{`np.dot`}</inlineCode></a>{` there are 5 type cases it supports.`}</p>\n    <ol>\n      <li parentName=\"ol\">\n        <p parentName=\"li\">{`Both arguments as `}<inlineCode parentName=\"p\">{`1D`}</inlineCode>{` arrays`}</p>\n      </li>\n      <li parentName=\"ol\">\n        <p parentName=\"li\">{`Both arguments are `}<inlineCode parentName=\"p\">{`2D`}</inlineCode>{` arrays (resulting in a `}<inlineCode parentName=\"p\">{`matmul`}</inlineCode>{`)`}</p>\n      </li>\n      <li parentName=\"ol\">\n        <p parentName=\"li\">{`Either arguments are scalars`}</p>\n      </li>\n      <li parentName=\"ol\">\n        <p parentName=\"li\">{`Either argument is a `}<inlineCode parentName=\"p\">{`ND`}</inlineCode>{` array and the other is a `}<inlineCode parentName=\"p\">{`1D`}</inlineCode>{` array`}</p>\n      </li>\n      <li parentName=\"ol\">\n        <p parentName=\"li\">{`One argument is `}<inlineCode parentName=\"p\">{`ND`}</inlineCode>{` array and the other is `}<inlineCode parentName=\"p\">{`MD`}</inlineCode>{` array`}</p>\n      </li>\n    </ol>\n    <p>{`We can implement these cases as follows`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-python\"\n      }}>{`ShapeVarGen = TypeVarTuple(\"ShapeVarGen\")\n\n@overload\ndef dot(x1: NDArray[Shape1D[T1], GenericDType], x2: NDArray[Shape1D[T1], GenericDType], /) -> GenericDType:\n    ...\n\n\n@overload\ndef dot(\n    x1: NDArray[Shape[T1, *ShapeVarGen], GenericDType], x2: NDArray[Shape1D[T1], GenericDType], /\n) -> NDArray[Shape[*ShapeVarGen], GenericDType]:\n    ...\n\n\n@overload\ndef dot(\n    x1: NDArray[Shape2D[T1, T2], GenericDType],\n    x2: NDArray[Shape2D[T2, T3], GenericDType],\n    /,\n) -> NDArray[Shape2D[T1, T3], GenericDType]:\n    ...\n\n\n@overload\ndef dot(x1: GenericDType, x2: GenericDType, /) -> GenericDType:\n    ...\n\n\ndef dot(x1, x2):\n    return np.dot(x1, x2)\n\n`}</code></pre>\n    <p>{`The only case we can't implement is an `}<inlineCode parentName=\"p\">{`ND`}</inlineCode>{` dimensional array with an `}<inlineCode parentName=\"p\">{`MD`}</inlineCode>{`\ndimensional array. Ideally we would try implementing it like so:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-python\"\n      }}>{`ShapeVarGen1 = TypeVarTuple(\"ShapeVarGen1\")\nShapeVarGen2 = TypeVarTuple(\"ShapeVarGen2\")\n\n@overload\ndef dot(\n    x1: NDArray[Shape[*ShapeVarGen1, T1], GenericDType], x2: NDArray[Shape[*ShapeVarGen2, T1, T2], GenericDType], /\n) -> NDArray[Shape[*ShapeVarGen1, *ShapeVarGen2], GenericDType]:\n    ...\n`}</code></pre>\n    <p>{`But currently using multiple type variable tuples `}<a parentName=\"p\" {...{\n        \"href\": \"https://peps.python.org/pep-0646/#multiple-type-variable-tuples-not-allowed\"\n      }}>{`is not allowed`}</a>{`. If you know\nof another way to cover this case let me know! Luckily for our `}<inlineCode parentName=\"p\">{`Linear`}</inlineCode>{` use\ncase, it only uses scalars, vectors, and matrices which is covered by our four\noverloads.`}</p>\n    <p>{`Here's how we would use these `}<inlineCode parentName=\"p\">{`dot`}</inlineCode>{` overloads to do the dot product between a\n`}<inlineCode parentName=\"p\">{`2x3`}</inlineCode>{` matrix and a `}<inlineCode parentName=\"p\">{`3x2`}</inlineCode>{` matrix with type hints:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-python\"\n      }}>{`import numpy as np\nfrom numpy.typing import NDArray\nfrom numpy_shape_typing.dot import dot\nfrom numpy_shape_typing.types import ShapeNDType, Shape2D\nfrom numpy_shape_typing.rand import rand_normal_matrix\n\nfrom typing import Literal\n\nTWO = Literal[2]\nTHREE = Literal[3]\nA: NDArray[Shape2D[TWO, THREE], np.float64] = rand_normal_matrix((2,3))\nB: NDArray[Shape2D[THREE, TWO], np.float64] = rand_normal_matrix((3,2))\nC: NDArray[Shape2D[TWO, TWO], np.float64] = dot(A, B)\nprint(C)\n`}</code></pre>\n    <p>{`And if we check with `}<inlineCode parentName=\"p\">{`pyright`}</inlineCode>{`:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-bash\"\n      }}>{`py -m pyright good_dot.py --lib\n`}</code></pre>\n    <p>{`Everything looks good as it should!`}</p>\n    <p>{`And if we change the types to invalid matrix shapes:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-python\"\n      }}>{`import numpy as np\nfrom numpy.typing import NDArray\nfrom numpy_shape_typing.dot import dot\nfrom numpy_shape_typing.rand import rand_normal_matrix\nfrom numpy_shape_typing.types import ShapeNDType, Shape2D\n\nfrom typing import Literal\n\nTWO = Literal[2]\nTHREE = Literal[3]\nFOUR = Literal[4]\nA: NDArray[Shape2D[TWO, THREE], np.float64] = rand_normal_matrix((2,3))\nB: NDArray[Shape2D[FOUR, FOUR], np.float64] = rand_normal_matrix((4,4))\n\n# uh oh bad shape type\nC: NDArray[Shape2D[TWO, TWO], np.float64] = dot(A, B)\nprint(C)\n`}</code></pre>\n    <p>{`And if we check with `}<inlineCode parentName=\"p\">{`pyright`}</inlineCode>{`:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-bash\"\n      }}>{`py -m pyright ./bad_dot.py --lib\n`}</code></pre>\n    <p><inlineCode parentName=\"p\">{`pyright`}</inlineCode>{` let's us know that the types we are using are incorrect shapes based\non `}<inlineCode parentName=\"p\">{`np.dot`}</inlineCode>{`'s type overloads we've specified.`}</p>\n    <h2 {...{\n      \"id\": \"even-moar-numpy-shape-typing\"\n    }}>{`Even moar `}<inlineCode parentName=\"h2\">{`numpy`}</inlineCode>{` shape typing!`}</h2>\n    <p>{`The next function we are going to type is `}<inlineCode parentName=\"p\">{`np.add`}</inlineCode>{`. The `}<a parentName=\"p\" {...{\n        \"href\": \"https://numpy.org/doc/stable/reference/generated/numpy.add.html\"\n      }}><inlineCode parentName=\"a\">{`numpy`}</inlineCode>{` docs`}</a>{` only show\ntwo cases.`}</p>\n    <ol>\n      <li parentName=\"ol\">\n        <p parentName=\"li\">{`Two `}<inlineCode parentName=\"p\">{`ND`}</inlineCode>{` array arguments of the same shape are added element wise`}</p>\n      </li>\n      <li parentName=\"ol\">\n        <p parentName=\"li\">{`Two `}<inlineCode parentName=\"p\">{`ND`}</inlineCode>{` array arguments that are not the same shape must be broadcastable to\na common shape`}</p>\n      </li>\n    </ol>\n    <p>{`Covering the first case is easy, but the second case is much harder as we\nwould have to come up with a scheme to cover `}<inlineCode parentName=\"p\">{`numpy`}</inlineCode>{`'s `}<a parentName=\"p\" {...{\n        \"href\": \"https://numpy.org/doc/stable/user/basics.broadcasting.html\"\n      }}>{`array broadcasting\nsystem`}</a>{`. Currently `}<inlineCode parentName=\"p\">{`python==3.11`}</inlineCode>{`'s `}<inlineCode parentName=\"p\">{`typing`}</inlineCode>{` doesn't have a generic way to\ncover all the broadcasting rules. (If you know of a way let me know!)`}</p>\n    <p>{`However if we scope down the second case to only two dimensions, we can cover\nall the array broadcasting rules with a few overloads:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-python\"\n      }}>{`from typing import overload\n\nimport numpy as np\nfrom numpy.typing import NDArray\n\nfrom numpy_shape_typing.types import ONE, T1, T2, GenericDType, Shape1D, Shape2D, ShapeVarGen\n\n\n@overload\ndef add(\n    x1: NDArray[Shape2D[T1, T2], GenericDType],\n    x2: NDArray[Shape1D[T2], GenericDType],\n    /,\n) -> NDArray[Shape2D[T1, T2], GenericDType]:\n    ...\n\n\n@overload\ndef add(\n    x1: NDArray[Shape1D[T2], GenericDType],\n    x2: NDArray[Shape2D[T1, T2], GenericDType],\n    /,\n) -> NDArray[Shape2D[T1, T2], GenericDType]:\n    ...\n\n\n@overload\ndef add(\n    x1: NDArray[Shape2D[T1, T2], GenericDType],\n    x2: NDArray[Shape1D[ONE], GenericDType],\n    /,\n) -> NDArray[Shape2D[T1, T2], GenericDType]:\n    ...\n\n\n@overload\ndef add(\n    x1: NDArray[Shape1D[ONE], GenericDType],\n    x2: NDArray[Shape2D[T1, T2], GenericDType],\n    /,\n) -> NDArray[Shape2D[T1, T2], GenericDType]:\n    ...\n\n\n@overload\ndef add(\n    x1: NDArray[Shape2D[T1, T2], GenericDType],\n    x2: NDArray[Shape2D[T1, ONE], GenericDType],\n    /,\n) -> NDArray[Shape2D[T1, T2], GenericDType]:\n    ...\n\n\n@overload\ndef add(\n    x1: NDArray[Shape2D[T1, T2], GenericDType],\n    x2: NDArray[Shape2D[ONE, T2], GenericDType],\n    /,\n) -> NDArray[Shape2D[T1, T2], GenericDType]:\n    ...\n\n\n@overload\ndef add(\n    x1: NDArray[Shape2D[T1, ONE], GenericDType],\n    x2: NDArray[Shape2D[T1, T2], GenericDType],\n    /,\n) -> NDArray[Shape2D[T1, T2], GenericDType]:\n    ...\n\n\n@overload\ndef add(\n    x1: NDArray[Shape2D[ONE, T2], GenericDType],\n    x2: NDArray[Shape2D[T1, T2], GenericDType],\n    /,\n) -> NDArray[Shape2D[T1, T2], GenericDType]:\n    ...\n\n\n@overload\ndef add(\n    x1: GenericDType,\n    x2: NDArray[Shape2D[T1, T2], GenericDType],\n    /,\n) -> NDArray[Shape2D[T1, T2], GenericDType]:\n    ...\n\n\n@overload\ndef add(\n    x1: NDArray[Shape2D[T1, T2], GenericDType],\n    x2: GenericDType,\n    /,\n) -> NDArray[Shape2D[T1, T2], GenericDType]:\n    ...\n\n\n@overload\ndef add(\n    x1: NDArray[*ShapeVarGen, GenericDType],\n    x2: NDArray[*ShapeVarGen, GenericDType],\n    /,\n) -> NDArray[*ShapeVarGen, GenericDType]:\n    ...\n\n\ndef add(x1, x2):\n    return np.add(x1, x2)\n`}</code></pre>\n    <p>{`Using these overloads, here is how we would catch unexpected array broadcasts\n(similar to the one from our original `}<inlineCode parentName=\"p\">{`Linear`}</inlineCode>{` example).`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-python\"\n      }}>{`from typing import Literal\n\nimport numpy as np\nfrom numpy.typing import NDArray\n\nfrom numpy_shape_typing.add import add\nfrom numpy_shape_typing.dot import dot\nfrom numpy_shape_typing.rand import rand_normal_matrix\nfrom numpy_shape_typing.types import ONE, Shape1D, Shape2D\n\nFOUR = Literal[4]\nA: NDArray[Shape2D[FOUR, FOUR], np.float64] = rand_normal_matrix((4, 4))\nB: NDArray[Shape2D[ONE, FOUR], np.float64] = rand_normal_matrix((1, 4))\nC: NDArray[Shape2D[ONE, FOUR], np.float64] = add(A, B)\nprint(C)\n`}</code></pre>\n    <p>{`In the example above, our output is a `}<inlineCode parentName=\"p\">{`4x4`}</inlineCode>{` matrix, but from our types we wanted\nan output shape of `}<inlineCode parentName=\"p\">{`4x1`}</inlineCode>{`. Let's see what `}<inlineCode parentName=\"p\">{`pyright`}</inlineCode>{` says`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-bash\"\n      }}>{`py -m pyright unnexpected_broadcast.py --lib\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"hitting-the-limitations-of-shape-typing-\"\n    }}>{`Hitting the limitations of shape typing ðŸ˜¿`}</h2>\n    <p>{`The last function we will type to finish of our `}<inlineCode parentName=\"p\">{`Linear`}</inlineCode>{` example is\n`}<inlineCode parentName=\"p\">{`np.ravel`}</inlineCode>{`. However this is where we start hitting some major limitations of\nshape typing as they exist today in `}<inlineCode parentName=\"p\">{`python`}</inlineCode>{` and `}<inlineCode parentName=\"p\">{`numpy`}</inlineCode>{`.`}</p>\n    <p>{`From the `}<a parentName=\"p\" {...{\n        \"href\": \"https://numpy.org/doc/stable/reference/generated/numpy.ravel.html\"\n      }}>{`numpy docs on`}</a>{` `}<inlineCode parentName=\"p\">{`np.ravel`}</inlineCode>{` the only case we need to cover is that any\n`}<inlineCode parentName=\"p\">{`ND`}</inlineCode>{` array gets collapsed into a `}<inlineCode parentName=\"p\">{`1D`}</inlineCode>{` array of size of the total number of\nelements. Luckily all the information to compute the final `}<inlineCode parentName=\"p\">{`1D`}</inlineCode>{` size is just\nthe product of all the input dimension sizes.`}</p>\n    <p>{`Ideally we would try to write code that looks something like this:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-python\"\n      }}>{`ShapeVarGen = TypeVarTuple(\"ShapeVarGen\")\n\n@overload\ndef ravel(\n    arr: NDArray[Shape[*ShapeVarGen], GenericDType]\n) -> NDArray[Shape1D[Product[*ShapeVarGen]], GenericDType]:\n    ...\n`}</code></pre>\n    <p>{`But unfortunately `}<inlineCode parentName=\"p\">{`python`}</inlineCode>{`'s `}<inlineCode parentName=\"p\">{`typing`}</inlineCode>{` package currently doesn't have a notion\nof a `}<inlineCode parentName=\"p\">{`Product`}</inlineCode>{` type that provides a way to do algebraic typing.`}</p>\n    <p>{`However for the sake of completion we can fake it!`}</p>\n    <p>{`If we scope down from a generic `}<inlineCode parentName=\"p\">{`ND`}</inlineCode>{` typing of `}<inlineCode parentName=\"p\">{`np.ravel`}</inlineCode>{` to support up to two\ndimensions and limit the size of the output dimension to some maximum number,\nwe can overload all the possible factors that multiply to the output dimension\nsize. We would effectively be typing a multiplication table ðŸ˜†, but it will\nwork and get us to a \"partially\" typed `}<inlineCode parentName=\"p\">{`np.ravel`}</inlineCode>{`.`}</p>\n    <p>{`Here's how we can do it.`}</p>\n    <p>{`First we create a bunch of `}<inlineCode parentName=\"p\">{`Literal`}</inlineCode>{` types (our factors):`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-python\"\n      }}>{`ZERO = Literal[0]\nONE = Literal[1]\nTWO = Literal[2]\nTHREE = Literal[3]\nFOUR = Literal[4]\n...\n`}</code></pre>\n    <p>{`Then we define \"multiply\" types for factor pairs of numbers:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-python\"\n      }}>{`SHAPE_2D_MUL_TO_ONE = TypeVar(\n    \"SHAPE_2D_MUL_TO_ONE\",\n    bound=Shape2D[Literal[ONE], Literal[ONE]],\n)\nSHAPE_2D_MUL_TO_TWO = TypeVar(\n    \"SHAPE_2D_MUL_TO_TWO\",\n    bound=Union[Shape2D[Literal[ONE], Literal[TWO]], Shape2D[Literal[TWO], Literal[ONE]]],\n)\nSHAPE_2D_MUL_TO_THREE = TypeVar(\n    \"SHAPE_2D_MUL_TO_THREE\",\n    bound=Union[Shape2D[Literal[ONE], Literal[THREE]], Shape2D[Literal[THREE], Literal[ONE]]],\n)\nSHAPE_2D_MUL_TO_FOUR = TypeVar(\n    \"SHAPE_2D_MUL_TO_FOUR\",\n    bound=Union[\n        Shape2D[Literal[ONE], Literal[FOUR]],\n        Shape2D[Literal[TWO], Literal[TWO]],\n        Shape2D[Literal[FOUR], Literal[ONE]],\n    ],\n)\n`}</code></pre>\n    <p>{`Then lastly we wire these types up into individual `}<inlineCode parentName=\"p\">{`ravel`}</inlineCode>{` overloads (and\ncover a few generic ones while we're at it):`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-python\"\n      }}>{`@overload\ndef ravel(arr: NDArray[SHAPE_2D_MUL_TO_ONE, GenericDType]) -> NDArray[Shape1D[ONE], GenericDType]:\n    ...\n\n\n@overload\ndef ravel(arr: NDArray[SHAPE_2D_MUL_TO_TWO, GenericDType]) -> NDArray[Shape1D[TWO], GenericDType]:\n    ...\n\n\n@overload\ndef ravel(arr: NDArray[SHAPE_2D_MUL_TO_THREE, GenericDType]) -> NDArray[Shape1D[THREE], GenericDType]:\n    ...\n\n\n@overload\ndef ravel(arr: NDArray[SHAPE_2D_MUL_TO_FOUR, GenericDType]) -> NDArray[Shape1D[FOUR], GenericDType]:\n    ...\n\n@overload\ndef ravel(arr: NDArray[Shape2D[T1, ONE], GenericDType]) -> NDArray[Shape1D[T1], GenericDType]:\n    ...\n\n\n@overload\ndef ravel(arr: NDArray[Shape2D[ONE, T1], GenericDType]) -> NDArray[Shape1D[T1], GenericDType]:\n    ...\n\n\n@overload\ndef ravel(arr: NDArray[Shape1D[T1], GenericDType]) -> NDArray[Shape1D[T1], GenericDType]:\n    ...\n`}</code></pre>\n    <p>{`Now we can rinse and repeat for as many numbers as we like!`}</p>\n    <p>{`Here is how we'd use this typing to catch a shape type error with `}<inlineCode parentName=\"p\">{`ravel`}</inlineCode>{`:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-python\"\n      }}>{`import numpy as np\nfrom numpy.typing import NDArray\n\nfrom numpy_shape_typing.rand import rand_normal_matrix\nfrom numpy_shape_typing.ravel import ravel\nfrom numpy_shape_typing.types import FOUR, SEVEN, TWO, Shape1D, Shape2D\n\nA: NDArray[Shape2D[TWO, FOUR], np.float64] = rand_normal_matrix((2, 4))\nB: NDArray[Shape1D[SEVEN], np.float64] = ravel(A)\nprint(B)\n`}</code></pre>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-bash\"\n      }}>{`py -m pyright raveling.py --lib\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"putting-it-all-together\"\n    }}>{`Putting it all together`}</h2>\n    <p>{`So far we've gone through typing a small subset of `}<inlineCode parentName=\"p\">{`numpy`}</inlineCode>{`'s functions\n(`}<inlineCode parentName=\"p\">{`np.random.standard_normal`}</inlineCode>{`, `}<inlineCode parentName=\"p\">{`np.dot`}</inlineCode>{`, `}<inlineCode parentName=\"p\">{`np.add`}</inlineCode>{`, and `}<inlineCode parentName=\"p\">{`np.ravel`}</inlineCode>{` in all).`}</p>\n    <p>{`Now we can chain these typed functions together to form a typed `}<inlineCode parentName=\"p\">{`Linear`}</inlineCode>{`\nimplementation like so:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-python\"\n      }}>{`from typing import Literal\n\nimport numpy as np\nfrom numpy.typing import NDArray\n\nfrom numpy_shape_typing.add import add\nfrom numpy_shape_typing.dot import dot\nfrom numpy_shape_typing.rand import rand_normal_matrix\nfrom numpy_shape_typing.ravel import ravel\nfrom numpy_shape_typing.types import ONE, T1, T2, GenericDType, Shape1D, Shape2D\n\n\ndef Linear(\n        A: NDArray[Shape2D[T1, T2], GenericDType],\n        x: NDArray[Shape2D[T2, ONE], GenericDType],\n        b: NDArray[Shape2D[T1, ONE], GenericDType],\n) -> NDArray[Shape1D[T1], GenericDType]:\n    Ax = dot(A, x)\n    Axb = add(Ax, b)\n    return ravel(Axb)\n\n\nIN_DIM = Literal[3]\nin_dim: IN_DIM = 3\n\nOUT_DIM = Literal[4]\nout_dim: OUT_DIM = 4\n\n# bad type >:(\nBAD_OUT_DIM = Literal[5]\n\nA: NDArray[Shape2D[OUT_DIM, IN_DIM], np.float64] = rand_normal_matrix((out_dim, in_dim))\nx: NDArray[Shape2D[IN_DIM, ONE], np.float64] = rand_normal_matrix((in_dim, 1))\nb: NDArray[Shape2D[OUT_DIM, ONE], np.float64] = rand_normal_matrix((out_dim, 1))\n\n# this is a bad type! we should have an output shape type of \"Shape1D[BAD_OUT_DIM]\"\ny: NDArray[Shape1D[BAD_OUT_DIM], np.float64] = Linear(A, x, b)\n`}</code></pre>\n    <p>{`I've included an intentional type error which should be caught by `}<inlineCode parentName=\"p\">{`pyright`}</inlineCode>{`\nlike so:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-bash\"\n      }}>{`py -m pyright linear_type_bad.py --lib\n`}</code></pre>\n    <p>{`And huzzah again! `}<inlineCode parentName=\"p\">{`pyright`}</inlineCode>{` has caught the shape type error!`}</p>\n    <p>{`And now we can fix this shape error by changing `}<inlineCode parentName=\"p\">{`BAD_OUT_DIM`}</inlineCode>{` to the correct\noutput dimension size.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-python\"\n      }}>{`from typing import Literal\n\nimport numpy as np\nfrom numpy.typing import NDArray\n\nfrom numpy_shape_typing.add import add\nfrom numpy_shape_typing.dot import dot\nfrom numpy_shape_typing.rand import rand_normal_matrix\nfrom numpy_shape_typing.ravel import ravel\nfrom numpy_shape_typing.types import ONE, T1, T2, GenericDType, Shape1D, Shape2D\n\n\ndef Linear(\n        A: NDArray[Shape2D[T1, T2], GenericDType],\n        x: NDArray[Shape2D[T2, ONE], GenericDType],\n        b: NDArray[Shape2D[T1, ONE], GenericDType],\n) -> NDArray[Shape1D[T1], GenericDType]:\n    Ax = dot(A, x)\n    Axb = add(Ax, b)\n    return ravel(Axb)\n\n\nIN_DIM = Literal[3]\nin_dim: IN_DIM = 3\n\nOUT_DIM = Literal[4]\nout_dim: OUT_DIM = 4\n\nA: NDArray[Shape2D[OUT_DIM, IN_DIM], np.float64] = rand_normal_matrix((out_dim, in_dim))\nx: NDArray[Shape2D[IN_DIM, ONE], np.float64] = rand_normal_matrix((in_dim, 1))\nb: NDArray[Shape2D[OUT_DIM, ONE], np.float64] = rand_normal_matrix((out_dim, 1))\ny: NDArray[Shape1D[OUT_DIM], np.float64] = Linear(A, x, b)\n`}</code></pre>\n    <p>{`And if we check with `}<inlineCode parentName=\"p\">{`pyright`}</inlineCode>{`.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-bash\"\n      }}>{`py -m pyright linear_type_good.py --lib\n`}</code></pre>\n    <p><inlineCode parentName=\"p\">{`pyright`}</inlineCode>{` tells us that our types are consistent!`}</p>\n\n    </MDXLayout>;\n}\n;\nMDXContent.isMDXComponent = true;\n      "],"names":["_frontmatter","layoutProps","MDXLayout","DefaultLayout","MDXContent","components","props","mdxType","parentName","isMDXComponent"],"sourceRoot":""}