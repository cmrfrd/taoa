"use strict";(self.__LOADABLE_LOADED_CHUNKS__=self.__LOADABLE_LOADED_CHUNKS__||[]).push([[191],{24984:function(e,n,a){a.r(n),a.d(n,{_frontmatter:function(){return l},default:function(){return m}});var t=a(87462),r=a(63366),p=(a(67294),a(10498)),i=a(36904),o=["components"],l={},s={_frontmatter:l},d=i.Z;function m(e){var n=e.components,a=(0,r.Z)(e,o);return(0,p.kt)(d,(0,t.Z)({},s,a,{components:n,mdxType:"MDXLayout"}),(0,p.kt)("p",null,"When doing any sort of tensor/array computation in python (via ",(0,p.kt)("inlineCode",{parentName:"p"},"numpy"),",\n",(0,p.kt)("inlineCode",{parentName:"p"},"pytorch"),", ",(0,p.kt)("inlineCode",{parentName:"p"},"jax"),", or other",">",">","), it's more frequent than not to encounter shape\nerrors like the one below"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-python"},"import numpy as np\n\nsize1 = (2,3)\nsize2 = (4,3)\n\nM1 = np.random.random(size=size1)\nM2 = np.random.random(size=size2)\n\ntry:\n    print(np.dot(M1,M2))\nexcept Exception as e:\n    print(e)\n")),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-text"},"shapes (2,3) and (4,3) not aligned: 3 (dim 1) != 4 (dim 0)\n")),(0,p.kt)("p",null,"And most of the time, these kind of errors boil down to something like\naccidentally forgetting to do a reshape or transpose like so."),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-python"},"import numpy as np\n\nsize1 = (2,3)\nsize2 = (4,3)\n\nM1 = np.random.random(size=size1)\nM2 = np.random.random(size=size2).T\n\ntry:\n    print(np.dot(M1,M2))\nexcept Exception as e:\n    print(e)\n")),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-text"},"[[0.30107944 0.77536851 1.09367428 0.40458726]\n [0.36731406 1.01442791 1.28123555 0.51842414]]\n")),(0,p.kt)("p",null,"And while this is a mild case, shape bugs like these become more frequent as\noperations grow more complex and as more dimensions are involved."),(0,p.kt)("p",null,"Here's a slightly more complex example of a ",(0,p.kt)("inlineCode",{parentName:"p"},"Linear")," implementation in ",(0,p.kt)("inlineCode",{parentName:"p"},"numpy"),"\nwith a subtle shape bug."),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-python"},'def Linear(A, x, b):\n    """\n    Takes matrix A (m x n) times a vector x (n x 1) and\n    adds a bias. The resulting ndarray is then ravelled\n    into a vector of size (m).\n    """\n    Ax = np.dot(A, x)\n    Axb = np.add(Ax, b)\n    return np.ravel(Axb)\n\nA = np.random.random(size=(4,4))\nx = np.random.random(size=(4,1))\nb = np.random.random(size=(4))\n\nresult = Linear(A, x, b)\nprint(result)\nprint(result.shape)\n')),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-text"},"[2.0367838  1.63654023 2.02552241 1.38342291 2.44376582 2.04352225\n 2.43250443 1.79040493 2.65987874 2.25963517 2.64861735 2.00651785\n 2.44294654 2.04270297 2.43168515 1.78958565]\n(16,)\n")),(0,p.kt)("p",null,"The docstring of ",(0,p.kt)("inlineCode",{parentName:"p"},"Linear")," clearly says the result should be size ",(0,p.kt)("inlineCode",{parentName:"p"},"m")," (or\n",(0,p.kt)("inlineCode",{parentName:"p"},"4"),"). But why then did we end up with a vector of size ",(0,p.kt)("inlineCode",{parentName:"p"},"16"),"? If we dig into\neach function we will eventually find that our problem is in how ",(0,p.kt)("inlineCode",{parentName:"p"},"numpy"),"\nhandles an ",(0,p.kt)("inlineCode",{parentName:"p"},"ndarray")," of a different shape."),(0,p.kt)("p",null,"If we break down ",(0,p.kt)("inlineCode",{parentName:"p"},"Linear"),", after ",(0,p.kt)("inlineCode",{parentName:"p"},"np.dot")," we have an ",(0,p.kt)("inlineCode",{parentName:"p"},"ndarray")," of shape\n",(0,p.kt)("inlineCode",{parentName:"p"},"(4,1)")," of which we do ",(0,p.kt)("inlineCode",{parentName:"p"},"np.add")," with a vector of shape ",(0,p.kt)("inlineCode",{parentName:"p"},"(4)"),". And here lies\nour bug. We might naturally think that ",(0,p.kt)("inlineCode",{parentName:"p"},"np.add")," will do this addition element\nwise, but instead we fell into an ",(0,p.kt)("a",{parentName:"p",href:"https://numpy.org/doc/stable/user/basics.broadcasting.html#broadcastable-arrays"},"array broadcasting")," trap. Array broadcasting\nare sets of rules ",(0,p.kt)("inlineCode",{parentName:"p"},"numpy")," uses to determine how to do arithmetic on different\nshaped ",(0,p.kt)("inlineCode",{parentName:"p"},"ndarrays"),". So instead of doing our computation element wise, ",(0,p.kt)("inlineCode",{parentName:"p"},"numpy"),"\ninterprets this as doing a broadcast operation of addition, resulting in a\n",(0,p.kt)("inlineCode",{parentName:"p"},"(4,4)"),' matrix, which subsequently gets "raveled" into a size ',(0,p.kt)("inlineCode",{parentName:"p"},"16")," vector."),(0,p.kt)("p",null,"Now to fix this is easy, we just need to initialize our ",(0,p.kt)("inlineCode",{parentName:"p"},"b")," variable to be of\nshape ",(0,p.kt)("inlineCode",{parentName:"p"},"(4,1)")," so ",(0,p.kt)("inlineCode",{parentName:"p"},"numpy")," will interpret the ",(0,p.kt)("inlineCode",{parentName:"p"},"np.add")," as an element wise\naddition."),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-python"},'def Linear(A, x, b):\n    """\n    Takes matrix A (m x n) times a vector x (n x 1) and\n    adds a bias. The resulting ndarray is then ravelled\n    into a vector of size (m).\n    """\n    Ax = np.dot(A, x)\n    Axb = np.add(Ax, b)\n    return np.ravel(Axb)\n\nA = np.random.random(size=(4,4))\nx = np.random.random(size=(4,1))\nb = np.random.random(size=(4,1))\n\nresult = Linear(A, x, b)\nprint(result)\nprint(result.shape)\n')),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-text"},"[1.72493875 0.91784843 1.57265948 1.49376213]\n(4,)\n")),(0,p.kt)("p",null,"We've solved the problem, but how can we be smarter to prevent this error from\nhappening again?"),(0,p.kt)("h2",{id:"existing-ways-to-stop-shape-bugs"},"Existing ways to stop shape bugs"),(0,p.kt)("p",null,"The simplest way we can try to stop this shape bug is with good docs. Ideally\nwe should always have good docs, but we can make it a point to include what\nthe shape expectations are like so:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-python"},'def Linear(A, x, b):\n    """\n    Args:\n        A: ndarray of shape (M x N)\n        x: ndarray of shape (N x 1)\n        b: ndarray of shape (M x 1)\n\n    Returns:\n        Linear output ndarray of shape (M)\n    """\n    Ax = np.dot(A, x) # Shape (M x 1)\n    Axb = np.add(Ax, b) # (M x 1) + (M x 1)\n    return np.ravel(Axb) # Shape (M)\n')),(0,p.kt)("p",null,"Now while informative, nothing is preventing us from encountering the same bug\nagain. The only benefit this gives us, is making the debugging process a\nbit easier."),(0,p.kt)("p",null,"We can do better."),(0,p.kt)("p",null,"Another approach in addition to good docs that's more of a preventative action\nis to use assertions. By sprinkling ",(0,p.kt)("inlineCode",{parentName:"p"},"assert")," throughout ",(0,p.kt)("inlineCode",{parentName:"p"},"Linear"),' with an\ninformative error message, we can "fail early" and start debugging like so:'),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-python"},'def Linear(A, x, b):\n    """\n    Args:\n        A: ndarray of shape (M x N)\n        x: ndarray of shape (N x 1)\n        b: ndarray of shape (M x 1)\n\n    Returns:\n        Linear output ndarray of shape (M)\n    """\n    assert len(A.shape) == 2, f"A must be of dim 2, not {len(A.shape)}"\n    Am, An = A.shape\n\n    assert x.shape == (An, 1), f"X must be shape ({An}, 1) to do dot"\n    Ax = np.dot(A, x) # Shape (M x 1)\n\n    assert b.shape == (Am, 1), f"Bias term must be shape ({Am}, 1)"\n    result = np.add(Ax, b) # (M x 1) + (M x 1)\n\n    ravel_result = np.ravel(result)\n    assert ravel_result.shape == (Am,), f"Uh oh, ravel result is shape {ravel_result.shape} and not {(Am,)}"\n    return ravel_result\n')),(0,p.kt)("p",null,"At every step of this function we do an ",(0,p.kt)("inlineCode",{parentName:"p"},"assert")," to make sure all the\n",(0,p.kt)("inlineCode",{parentName:"p"},"ndarray")," shapes are what we expect."),(0,p.kt)("p",null,"As a result ",(0,p.kt)("inlineCode",{parentName:"p"},"Linear"),' is a bit "safer". But compared to what we had originally,\nthis approach is much less readable. We also inherit some of the baggage that\ncomes with runtime error checking like:'),(0,p.kt)("ul",null,(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("p",{parentName:"li"},(0,p.kt)("strong",{parentName:"p"},"Incomplete checking"),": Have we checked all expected shape failure modes?")),(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("p",{parentName:"li"},(0,p.kt)("strong",{parentName:"p"},"Slow debugging cycles"),": How many refactor-",">","run cycles will we have to do\npass the checks?")),(0,p.kt)("li",{parentName:"ul"},(0,p.kt)("p",{parentName:"li"},(0,p.kt)("strong",{parentName:"p"},"Additional testing"),": Do we have to update our tests cover our runtime error\nchecks?"))),(0,p.kt)("p",null,"Overall runtime error checking is not a bad thing. In most cases it's very\nnecessary! But when it comes to shape errors, we can leverage an additional\napproach, static type checking."),(0,p.kt)("p",null,"Even though ",(0,p.kt)("inlineCode",{parentName:"p"},"python")," is a dynamically typed language, in ",(0,p.kt)("inlineCode",{parentName:"p"},"python>=3.5")," the\n",(0,p.kt)("inlineCode",{parentName:"p"},"typing")," module was introduced to enable static type checkers to validate type\nhinted ",(0,p.kt)("inlineCode",{parentName:"p"},"python")," code. (See ",(0,p.kt)("a",{parentName:"p",href:"https://www.youtube.com/watch?v=2wDvzy6Hgxg"},"this video")," for more details)"),(0,p.kt)("p",null,"Over time many third party libraries (like ",(0,p.kt)("inlineCode",{parentName:"p"},"numpy"),") have started to type hint\ntheir codebases which we can use to our benefit."),(0,p.kt)("p",null,"In order to help us prevent shape errors, let's see what typing capabilities\nexist in ",(0,p.kt)("inlineCode",{parentName:"p"},"numpy"),"."),(0,p.kt)("h2",{id:"dtype-typing-numpy-arrays"},(0,p.kt)("inlineCode",{parentName:"h2"},"dtype")," typing ",(0,p.kt)("inlineCode",{parentName:"h2"},"numpy")," arrays"),(0,p.kt)("p",null,"As of writing this post, ",(0,p.kt)("inlineCode",{parentName:"p"},"numpy==v1.24.2")," only supports typing on an\n",(0,p.kt)("inlineCode",{parentName:"p"},"ndarray"),"'s ",(0,p.kt)("inlineCode",{parentName:"p"},"dtype")," (",(0,p.kt)("inlineCode",{parentName:"p"},"uint8"),", ",(0,p.kt)("inlineCode",{parentName:"p"},"float64"),", etc.)."),(0,p.kt)("p",null,"Using ",(0,p.kt)("inlineCode",{parentName:"p"},"numpy"),"'s existing type hinting tooling, here's how we would include\n",(0,p.kt)("inlineCode",{parentName:"p"},"dtype")," type information to our ",(0,p.kt)("inlineCode",{parentName:"p"},"Linear")," example (note: there is an\nintentional type error)"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-python"},'from typing import TypeVar\n\nimport numpy as np\nfrom numpy.typing import NDArray\n\nGenericType = TypeVar("GenericType", bound=np.generic)\n\n\ndef Linear(\n        A: NDArray[GenericType],\n        x: NDArray[GenericType],\n        b: NDArray[GenericType],\n) -> NDArray[GenericType]:\n    """\n    Args:\n        A: ndarray of shape (M x N)\n        x: ndarray of shape (N x 1)\n        b: ndarray of shape (M x 1)\n\n    Returns:\n\n        Linear output ndarray of shape (M)\n    """\n    assert len(A.shape) == 2, f"A must be of dim 2, not {len(A.shape)}"\n    Am, An = A.shape\n\n    assert x.shape == (An, 1), f"X must be shape ({An}, 1) to do dot"\n    Ax: NDArray[GenericType] = np.dot(A, x)  # Shape (M x 1)\n\n    assert b.shape == (Am, 1), f"Bias term must be shape ({Am}, 1)"\n    result: NDArray[GenericType] = np.add(Ax, b)  # (M x 1) + (M x 1)\n\n    ravel_result: NDArray[GenericType] = np.ravel(result)\n    assert ravel_result.shape == (Am,), f"Uh oh, ravel result is shape {ravel_result.shape} and not {(Am,)}"\n    return ravel_result\n\n\nA: NDArray[np.float64] = np.random.standard_normal(size=(10, 10))\nx: NDArray[np.float64] = np.random.standard_normal(size=(10, 1))\nb: NDArray[np.float32] = np.random.standard_normal(size=(10, 1))\ny: NDArray[np.float64] = Linear(A, x, b)\nprint(y)\nprint(y.dtype)\n')),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-text"},"[-0.38677273 -2.68384527  1.19333451 -0.18736847 -3.43392021 -1.51889879\n  5.6047523   3.97918204  2.54240063  1.95581106]\nfloat64\n")),(0,p.kt)("p",null,'Even though this code is "runnable" and doesn\'t produce an error, a type\nchecker like ',(0,p.kt)("inlineCode",{parentName:"p"},"pyright")," tells us a different story."),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-bash"},"pyright linear_bad_typing.py\n")),(0,p.kt)("p",null,(0,p.kt)("inlineCode",{parentName:"p"},"pyright")," has noticed that when we create our ",(0,p.kt)("inlineCode",{parentName:"p"},"b")," variable, we gave it a\n",(0,p.kt)("inlineCode",{parentName:"p"},"dtype")," type that is incompatible with ",(0,p.kt)("inlineCode",{parentName:"p"},"np.random.standard_normal"),"."),(0,p.kt)("p",null,"Now we know to adjust the type hint of ",(0,p.kt)("inlineCode",{parentName:"p"},"b")," to be in line with the ",(0,p.kt)("inlineCode",{parentName:"p"},"dtype")," that\nis expected of ",(0,p.kt)("inlineCode",{parentName:"p"},"np.random.standard_normal")," (",(0,p.kt)("inlineCode",{parentName:"p"},"NDArray[np.float64]"),")."),(0,p.kt)("h2",{id:"shape-typing-numpy-arrays"},"Shape typing ",(0,p.kt)("inlineCode",{parentName:"h2"},"numpy")," arrays"),(0,p.kt)("p",null,"While ",(0,p.kt)("inlineCode",{parentName:"p"},"dtype")," typing is great, it's not the most useful for preventing shape\nerrors (like from our original example)."),(0,p.kt)("p",null,"Ideally it would be great if in addition to a ",(0,p.kt)("inlineCode",{parentName:"p"},"dtype")," type, we can also\ninclude information about an ",(0,p.kt)("inlineCode",{parentName:"p"},"ndarray"),"'s shape to do shape typing."),(0,p.kt)("p",null,"Shape typing is a technique used to annotate information about the\ndimensionality and size of an array. In the context of ",(0,p.kt)("inlineCode",{parentName:"p"},"numpy")," and the\n",(0,p.kt)("inlineCode",{parentName:"p"},"python")," type hinting system, we can use shape typing catch shape errors\nbefore runtime."),(0,p.kt)("blockquote",null,(0,p.kt)("p",{parentName:"blockquote"},"For more information about shape typing checkout ",(0,p.kt)("a",{parentName:"p",href:"https://docs.google.com/document/d/1But-hjet8-djv519HEKvBN6Ik2lW3yu0ojZo6pG9osY/edit#heading=h.aw3bt3fg1s2w"},"this google doc on a shape\ntyping syntax proposal")," by Matthew Rahtz, JÃ¶rg Bornschein, Vlad Mikulik, Tim\nHarley, Matthew Willson, Dimitrios Vytiniotis, Sergei Lebedev, Adam Paszke.")),(0,p.kt)("p",null,"As we've seen, ",(0,p.kt)("inlineCode",{parentName:"p"},"numpy"),"'s ",(0,p.kt)("inlineCode",{parentName:"p"},"NDArray")," currently only supports ",(0,p.kt)("inlineCode",{parentName:"p"},"dtype")," typing and\ndoesn't have any of this kind of shape typing ability. But why is that? If we\ndig into the definition of the ",(0,p.kt)("inlineCode",{parentName:"p"},"NDArray")," type:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-python"},'ScalarType = TypeVar("ScalarType", bound=np.generic, covariant=True)\n\nif TYPE_CHECKING or sys.version_info >= (3, 9):\n    _DType = np.dtype[ScalarType]\n    NDArray = np.ndarray[Any, np.dtype[ScalarType]]\nelse:\n    _DType = _GenericAlias(np.dtype, (ScalarType,))\n    NDArray = _GenericAlias(np.ndarray, (Any, _DType))\n')),(0,p.kt)("p",null,"And follow the definition of ",(0,p.kt)("inlineCode",{parentName:"p"},"np.ndarray")," ..."),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-python"},"class ndarray(_ArrayOrScalarCommon, Generic[_ShapeType, _DType_co]):\n")),(0,p.kt)("p",null,"We can see that it looks like ",(0,p.kt)("inlineCode",{parentName:"p"},"numpy")," uses a ",(0,p.kt)("inlineCode",{parentName:"p"},"Shape")," type already! But\nunfortunately if we look at the definition for this ..."),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-python"},'# TODO: Set the `bound` to something more suitable once we\n# have proper shape support\n_ShapeType = TypeVar("_ShapeType", bound=Any)\n_ShapeType2 = TypeVar("_ShapeType2", bound=Any)\n')),(0,p.kt)("p",null,"ðŸ˜­ Looks like we're stuck with ",(0,p.kt)("inlineCode",{parentName:"p"},"Any")," which doesn't add any useful shape\ninformation on our types."),(0,p.kt)("p",null,"Luckily for us, we don't have to wait for shape support in ",(0,p.kt)("inlineCode",{parentName:"p"},"numpy"),". ",(0,p.kt)("a",{parentName:"p",href:"https://peps.python.org/pep-0646/"},"PEP 646")," has\nthe base foundation for shape typing and has already been accepted into python\n",(0,p.kt)("inlineCode",{parentName:"p"},"3.11"),"! And it's supported by ",(0,p.kt)("inlineCode",{parentName:"p"},"pyright"),"! Theoretically these two things give\nus most of the ingredients to do basic shape typing."),(0,p.kt)("p",null,"Now this blog post isn't about the details of ",(0,p.kt)("a",{parentName:"p",href:"https://peps.python.org/pep-0646/"},"PEP 646")," or variadic\ngenerics. But the rest of this post will assume you know the basics of how\nthey work."),(0,p.kt)("p",null,"In order to add rudimentary shape typing to ",(0,p.kt)("inlineCode",{parentName:"p"},"numpy")," we can simply change the\n",(0,p.kt)("inlineCode",{parentName:"p"},"Any")," type in the ",(0,p.kt)("inlineCode",{parentName:"p"},"NDArray")," type definition to an unpacked variadic generic\nlike so:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-python"},'ScalarType = TypeVar("ScalarType", bound=np.generic, covariant=True)\nShape = TypeVarTuple("Shape")\n\nif TYPE_CHECKING or sys.version_info >= (3, 9):\n    _DType = np.dtype[ScalarType]\n    NDArray = np.ndarray[*Shape, np.dtype[ScalarType]]\nelse:\n    _DType = _GenericAlias(np.dtype, (ScalarType,))\n    NDArray = _GenericAlias(np.ndarray, (Any, _DType))\n')),(0,p.kt)("p",null,"Doing so allows us to fill in a ",(0,p.kt)("inlineCode",{parentName:"p"},"Tuple")," based type (indicating shape) in an\n",(0,p.kt)("inlineCode",{parentName:"p"},"NDArray")," alongside a ",(0,p.kt)("inlineCode",{parentName:"p"},"dtype")," type. And shape typing with ",(0,p.kt)("inlineCode",{parentName:"p"},"Tuple"),"'s enables us\ndefine function overloads which describe to a type checker the possible ways a\nfunction can change the shape of an ",(0,p.kt)("inlineCode",{parentName:"p"},"NDArray"),"."),(0,p.kt)("p",null,"Let's look at an example of using these concepts to type a wrapper function\nfor ",(0,p.kt)("inlineCode",{parentName:"p"},"np.random.standard_normal")," from our ",(0,p.kt)("inlineCode",{parentName:"p"},"Linear")," example with an intentional\ntype error:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-python"},'import numpy as np\nfrom numpy.typing import NDArray\nfrom typing import Tuple, TypeVar, Literal\n\n# Generic dimension sizes types\nT1 = TypeVar("T1", bound=int)\nT2 = TypeVar("T2", bound=int)\nT3 = TypeVar("T3", bound=int)\n\n# Dimension types represented as typles\nShape = Tuple\nShape1D = Shape[T1]\nShape2D = Shape[T1, T2]\nShape3D = Shape[T1, T2, T3]\nShapeND = Shape[T1, ...]\nShapeNDType = TypeVar("ShapeNDType", bound=ShapeND)\n\ndef rand_normal_matrix(shape: ShapeNDType) -> NDArray[ShapeNDType, np.float64]:\n    """Return a random ND normal matrix."""\n    return np.random.standard_normal(size=shape)\n\n# Yay correctly typed 2x2x2 cube!\nTWO = Literal[2]\ntwo_by_two_by_two: NDArray[Shape3D[TWO, TWO, TWO], np.float64] = rand_normal_matrix((2,2,2))\nprint(two_by_two_by_two)\n\nFOUR = Literal[4]\n\n# Uh oh the shapes won\'t match!\nfour_by_four: NDArray[Shape2D[FOUR, FOUR], np.float64] = rand_normal_matrix((3,3))\nprint(four_by_four)\n')),(0,p.kt)("p",null,"Notice here there are no ",(0,p.kt)("inlineCode",{parentName:"p"},"assert")," statements. And instead of several comments\nabout shape, we indicate shape in the type hint."),(0,p.kt)("p",null,'Now while this code is "runnable", ',(0,p.kt)("inlineCode",{parentName:"p"},"pyright")," will tell us something else:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-bash"},"py -m pyright bad_shape_typing.py --lib\n")),(0,p.kt)("p",null,(0,p.kt)("inlineCode",{parentName:"p"},"pyright")," is telling us we've incorrectly typed ",(0,p.kt)("inlineCode",{parentName:"p"},"four_by_four")," and that it's\nincompatible with a ",(0,p.kt)("inlineCode",{parentName:"p"},"3x3")," shape. Now we know we need to go back and fix the\ntype to what a type checker should expect."),(0,p.kt)("p",null,"Huzzah shape typing!!"),(0,p.kt)("h2",{id:"moar-numpy-shape-typing"},"Moar ",(0,p.kt)("inlineCode",{parentName:"h2"},"numpy")," shape typing!"),(0,p.kt)("p",null,"Now that we have shape typed one function, let's step it up a notch. Let's try\ntyping each ",(0,p.kt)("inlineCode",{parentName:"p"},"numpy")," function in our ",(0,p.kt)("inlineCode",{parentName:"p"},"Linear")," example to include shape\ntypes. We've already typed ",(0,p.kt)("inlineCode",{parentName:"p"},"np.random.standard_normal"),", so next let's do\n",(0,p.kt)("inlineCode",{parentName:"p"},"np.dot"),"."),(0,p.kt)("p",null,"If we look at the ",(0,p.kt)("a",{parentName:"p",href:"https://numpy.org/doc/stable/reference/generated/numpy.dot.html"},"docs for ",(0,p.kt)("inlineCode",{parentName:"a"},"np.dot"))," there are 5 type cases it supports."),(0,p.kt)("ol",null,(0,p.kt)("li",{parentName:"ol"},(0,p.kt)("p",{parentName:"li"},"Both arguments as ",(0,p.kt)("inlineCode",{parentName:"p"},"1D")," arrays")),(0,p.kt)("li",{parentName:"ol"},(0,p.kt)("p",{parentName:"li"},"Both arguments are ",(0,p.kt)("inlineCode",{parentName:"p"},"2D")," arrays (resulting in a ",(0,p.kt)("inlineCode",{parentName:"p"},"matmul"),")")),(0,p.kt)("li",{parentName:"ol"},(0,p.kt)("p",{parentName:"li"},"Either arguments are scalars")),(0,p.kt)("li",{parentName:"ol"},(0,p.kt)("p",{parentName:"li"},"Either argument is a ",(0,p.kt)("inlineCode",{parentName:"p"},"ND")," array and the other is a ",(0,p.kt)("inlineCode",{parentName:"p"},"1D")," array")),(0,p.kt)("li",{parentName:"ol"},(0,p.kt)("p",{parentName:"li"},"One argument is ",(0,p.kt)("inlineCode",{parentName:"p"},"ND")," array and the other is ",(0,p.kt)("inlineCode",{parentName:"p"},"MD")," array"))),(0,p.kt)("p",null,"We can implement these cases as follows"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-python"},'ShapeVarGen = TypeVarTuple("ShapeVarGen")\n\n@overload\ndef dot(x1: NDArray[Shape1D[T1], GenericDType], x2: NDArray[Shape1D[T1], GenericDType], /) -> GenericDType:\n    ...\n\n\n@overload\ndef dot(\n    x1: NDArray[Shape[T1, *ShapeVarGen], GenericDType], x2: NDArray[Shape1D[T1], GenericDType], /\n) -> NDArray[Shape[*ShapeVarGen], GenericDType]:\n    ...\n\n\n@overload\ndef dot(\n    x1: NDArray[Shape2D[T1, T2], GenericDType],\n    x2: NDArray[Shape2D[T2, T3], GenericDType],\n    /,\n) -> NDArray[Shape2D[T1, T3], GenericDType]:\n    ...\n\n\n@overload\ndef dot(x1: GenericDType, x2: GenericDType, /) -> GenericDType:\n    ...\n\n\ndef dot(x1, x2):\n    return np.dot(x1, x2)\n\n')),(0,p.kt)("p",null,"The only case we can't implement is an ",(0,p.kt)("inlineCode",{parentName:"p"},"ND")," dimensional array with an ",(0,p.kt)("inlineCode",{parentName:"p"},"MD"),"\ndimensional array. Ideally we would try implementing it like so:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-python"},'ShapeVarGen1 = TypeVarTuple("ShapeVarGen1")\nShapeVarGen2 = TypeVarTuple("ShapeVarGen2")\n\n@overload\ndef dot(\n    x1: NDArray[Shape[*ShapeVarGen1, T1], GenericDType], x2: NDArray[Shape[*ShapeVarGen2, T1, T2], GenericDType], /\n) -> NDArray[Shape[*ShapeVarGen1, *ShapeVarGen2], GenericDType]:\n    ...\n')),(0,p.kt)("p",null,"But currently using multiple type variable tuples ",(0,p.kt)("a",{parentName:"p",href:"https://peps.python.org/pep-0646/#multiple-type-variable-tuples-not-allowed"},"is not allowed"),". If you know\nof another way to cover this case let me know! Luckily for our ",(0,p.kt)("inlineCode",{parentName:"p"},"Linear")," use\ncase, it only uses scalars, vectors, and matrices which is covered by our four\noverloads."),(0,p.kt)("p",null,"Here's how we would use these ",(0,p.kt)("inlineCode",{parentName:"p"},"dot")," overloads to do the dot product between a\n",(0,p.kt)("inlineCode",{parentName:"p"},"2x3")," matrix and a ",(0,p.kt)("inlineCode",{parentName:"p"},"3x2")," matrix with type hints:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-python"},"import numpy as np\nfrom numpy.typing import NDArray\nfrom numpy_shape_typing.dot import dot\nfrom numpy_shape_typing.types import ShapeNDType, Shape2D\nfrom numpy_shape_typing.rand import rand_normal_matrix\n\nfrom typing import Literal\n\nTWO = Literal[2]\nTHREE = Literal[3]\nA: NDArray[Shape2D[TWO, THREE], np.float64] = rand_normal_matrix((2,3))\nB: NDArray[Shape2D[THREE, TWO], np.float64] = rand_normal_matrix((3,2))\nC: NDArray[Shape2D[TWO, TWO], np.float64] = dot(A, B)\nprint(C)\n")),(0,p.kt)("p",null,"And if we check with ",(0,p.kt)("inlineCode",{parentName:"p"},"pyright"),":"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-bash"},"py -m pyright good_dot.py --lib\n")),(0,p.kt)("p",null,"Everything looks good as it should!"),(0,p.kt)("p",null,"And if we change the types to invalid matrix shapes:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-python"},"import numpy as np\nfrom numpy.typing import NDArray\nfrom numpy_shape_typing.dot import dot\nfrom numpy_shape_typing.rand import rand_normal_matrix\nfrom numpy_shape_typing.types import ShapeNDType, Shape2D\n\nfrom typing import Literal\n\nTWO = Literal[2]\nTHREE = Literal[3]\nFOUR = Literal[4]\nA: NDArray[Shape2D[TWO, THREE], np.float64] = rand_normal_matrix((2,3))\nB: NDArray[Shape2D[FOUR, FOUR], np.float64] = rand_normal_matrix((4,4))\n\n# uh oh bad shape type\nC: NDArray[Shape2D[TWO, TWO], np.float64] = dot(A, B)\nprint(C)\n")),(0,p.kt)("p",null,"And if we check with ",(0,p.kt)("inlineCode",{parentName:"p"},"pyright"),":"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-bash"},"py -m pyright ./bad_dot.py --lib\n")),(0,p.kt)("p",null,(0,p.kt)("inlineCode",{parentName:"p"},"pyright")," let's us know that the types we are using are incorrect shapes based\non ",(0,p.kt)("inlineCode",{parentName:"p"},"np.dot"),"'s type overloads we've specified."),(0,p.kt)("h2",{id:"even-moar-numpy-shape-typing"},"Even moar ",(0,p.kt)("inlineCode",{parentName:"h2"},"numpy")," shape typing!"),(0,p.kt)("p",null,"The next function we are going to type is ",(0,p.kt)("inlineCode",{parentName:"p"},"np.add"),". The ",(0,p.kt)("a",{parentName:"p",href:"https://numpy.org/doc/stable/reference/generated/numpy.add.html"},(0,p.kt)("inlineCode",{parentName:"a"},"numpy")," docs")," only show\ntwo cases."),(0,p.kt)("ol",null,(0,p.kt)("li",{parentName:"ol"},(0,p.kt)("p",{parentName:"li"},"Two ",(0,p.kt)("inlineCode",{parentName:"p"},"ND")," array arguments of the same shape are added element wise")),(0,p.kt)("li",{parentName:"ol"},(0,p.kt)("p",{parentName:"li"},"Two ",(0,p.kt)("inlineCode",{parentName:"p"},"ND")," array arguments that are not the same shape must be broadcastable to\na common shape"))),(0,p.kt)("p",null,"Covering the first case is easy, but the second case is much harder as we\nwould have to come up with a scheme to cover ",(0,p.kt)("inlineCode",{parentName:"p"},"numpy"),"'s ",(0,p.kt)("a",{parentName:"p",href:"https://numpy.org/doc/stable/user/basics.broadcasting.html"},"array broadcasting\nsystem"),". Currently ",(0,p.kt)("inlineCode",{parentName:"p"},"python==3.11"),"'s ",(0,p.kt)("inlineCode",{parentName:"p"},"typing")," doesn't have a generic way to\ncover all the broadcasting rules. (If you know of a way let me know!)"),(0,p.kt)("p",null,"However if we scope down the second case to only two dimensions, we can cover\nall the array broadcasting rules with a few overloads:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-python"},"from typing import overload\n\nimport numpy as np\nfrom numpy.typing import NDArray\n\nfrom numpy_shape_typing.types import ONE, T1, T2, GenericDType, Shape1D, Shape2D, ShapeVarGen\n\n\n@overload\ndef add(\n    x1: NDArray[Shape2D[T1, T2], GenericDType],\n    x2: NDArray[Shape1D[T2], GenericDType],\n    /,\n) -> NDArray[Shape2D[T1, T2], GenericDType]:\n    ...\n\n\n@overload\ndef add(\n    x1: NDArray[Shape1D[T2], GenericDType],\n    x2: NDArray[Shape2D[T1, T2], GenericDType],\n    /,\n) -> NDArray[Shape2D[T1, T2], GenericDType]:\n    ...\n\n\n@overload\ndef add(\n    x1: NDArray[Shape2D[T1, T2], GenericDType],\n    x2: NDArray[Shape1D[ONE], GenericDType],\n    /,\n) -> NDArray[Shape2D[T1, T2], GenericDType]:\n    ...\n\n\n@overload\ndef add(\n    x1: NDArray[Shape1D[ONE], GenericDType],\n    x2: NDArray[Shape2D[T1, T2], GenericDType],\n    /,\n) -> NDArray[Shape2D[T1, T2], GenericDType]:\n    ...\n\n\n@overload\ndef add(\n    x1: NDArray[Shape2D[T1, T2], GenericDType],\n    x2: NDArray[Shape2D[T1, ONE], GenericDType],\n    /,\n) -> NDArray[Shape2D[T1, T2], GenericDType]:\n    ...\n\n\n@overload\ndef add(\n    x1: NDArray[Shape2D[T1, T2], GenericDType],\n    x2: NDArray[Shape2D[ONE, T2], GenericDType],\n    /,\n) -> NDArray[Shape2D[T1, T2], GenericDType]:\n    ...\n\n\n@overload\ndef add(\n    x1: NDArray[Shape2D[T1, ONE], GenericDType],\n    x2: NDArray[Shape2D[T1, T2], GenericDType],\n    /,\n) -> NDArray[Shape2D[T1, T2], GenericDType]:\n    ...\n\n\n@overload\ndef add(\n    x1: NDArray[Shape2D[ONE, T2], GenericDType],\n    x2: NDArray[Shape2D[T1, T2], GenericDType],\n    /,\n) -> NDArray[Shape2D[T1, T2], GenericDType]:\n    ...\n\n\n@overload\ndef add(\n    x1: GenericDType,\n    x2: NDArray[Shape2D[T1, T2], GenericDType],\n    /,\n) -> NDArray[Shape2D[T1, T2], GenericDType]:\n    ...\n\n\n@overload\ndef add(\n    x1: NDArray[Shape2D[T1, T2], GenericDType],\n    x2: GenericDType,\n    /,\n) -> NDArray[Shape2D[T1, T2], GenericDType]:\n    ...\n\n\n@overload\ndef add(\n    x1: NDArray[*ShapeVarGen, GenericDType],\n    x2: NDArray[*ShapeVarGen, GenericDType],\n    /,\n) -> NDArray[*ShapeVarGen, GenericDType]:\n    ...\n\n\ndef add(x1, x2):\n    return np.add(x1, x2)\n")),(0,p.kt)("p",null,"Using these overloads, here is how we would catch unexpected array broadcasts\n(similar to the one from our original ",(0,p.kt)("inlineCode",{parentName:"p"},"Linear")," example)."),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-python"},"from typing import Literal\n\nimport numpy as np\nfrom numpy.typing import NDArray\n\nfrom numpy_shape_typing.add import add\nfrom numpy_shape_typing.dot import dot\nfrom numpy_shape_typing.rand import rand_normal_matrix\nfrom numpy_shape_typing.types import ONE, Shape1D, Shape2D\n\nFOUR = Literal[4]\nA: NDArray[Shape2D[FOUR, FOUR], np.float64] = rand_normal_matrix((4, 4))\nB: NDArray[Shape2D[ONE, FOUR], np.float64] = rand_normal_matrix((1, 4))\nC: NDArray[Shape2D[ONE, FOUR], np.float64] = add(A, B)\nprint(C)\n")),(0,p.kt)("p",null,"In the example above, our output is a ",(0,p.kt)("inlineCode",{parentName:"p"},"4x4")," matrix, but from our types we wanted\nan output shape of ",(0,p.kt)("inlineCode",{parentName:"p"},"4x1"),". Let's see what ",(0,p.kt)("inlineCode",{parentName:"p"},"pyright")," says"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-bash"},"py -m pyright unnexpected_broadcast.py --lib\n")),(0,p.kt)("h2",{id:"hitting-the-limitations-of-shape-typing-"},"Hitting the limitations of shape typing ðŸ˜¿"),(0,p.kt)("p",null,"The last function we will type to finish of our ",(0,p.kt)("inlineCode",{parentName:"p"},"Linear")," example is\n",(0,p.kt)("inlineCode",{parentName:"p"},"np.ravel"),". However this is where we start hitting some major limitations of\nshape typing as they exist today in ",(0,p.kt)("inlineCode",{parentName:"p"},"python")," and ",(0,p.kt)("inlineCode",{parentName:"p"},"numpy"),"."),(0,p.kt)("p",null,"From the ",(0,p.kt)("a",{parentName:"p",href:"https://numpy.org/doc/stable/reference/generated/numpy.ravel.html"},"numpy docs on")," ",(0,p.kt)("inlineCode",{parentName:"p"},"np.ravel")," the only case we need to cover is that any\n",(0,p.kt)("inlineCode",{parentName:"p"},"ND")," array gets collapsed into a ",(0,p.kt)("inlineCode",{parentName:"p"},"1D")," array of size of the total number of\nelements. Luckily all the information to compute the final ",(0,p.kt)("inlineCode",{parentName:"p"},"1D")," size is just\nthe product of all the input dimension sizes."),(0,p.kt)("p",null,"Ideally we would try to write code that looks something like this:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-python"},'ShapeVarGen = TypeVarTuple("ShapeVarGen")\n\n@overload\ndef ravel(\n    arr: NDArray[Shape[*ShapeVarGen], GenericDType]\n) -> NDArray[Shape1D[Product[*ShapeVarGen]], GenericDType]:\n    ...\n')),(0,p.kt)("p",null,"But unfortunately ",(0,p.kt)("inlineCode",{parentName:"p"},"python"),"'s ",(0,p.kt)("inlineCode",{parentName:"p"},"typing")," package currently doesn't have a notion\nof a ",(0,p.kt)("inlineCode",{parentName:"p"},"Product")," type that provides a way to do algebraic typing."),(0,p.kt)("p",null,"However for the sake of completion we can fake it!"),(0,p.kt)("p",null,"If we scope down from a generic ",(0,p.kt)("inlineCode",{parentName:"p"},"ND")," typing of ",(0,p.kt)("inlineCode",{parentName:"p"},"np.ravel"),' to support up to two\ndimensions and limit the size of the output dimension to some maximum number,\nwe can overload all the possible factors that multiply to the output dimension\nsize. We would effectively be typing a multiplication table ðŸ˜†, but it will\nwork and get us to a "partially" typed ',(0,p.kt)("inlineCode",{parentName:"p"},"np.ravel"),"."),(0,p.kt)("p",null,"Here's how we can do it."),(0,p.kt)("p",null,"First we create a bunch of ",(0,p.kt)("inlineCode",{parentName:"p"},"Literal")," types (our factors):"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-python"},"ZERO = Literal[0]\nONE = Literal[1]\nTWO = Literal[2]\nTHREE = Literal[3]\nFOUR = Literal[4]\n...\n")),(0,p.kt)("p",null,'Then we define "multiply" types for factor pairs of numbers:'),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-python"},'SHAPE_2D_MUL_TO_ONE = TypeVar(\n    "SHAPE_2D_MUL_TO_ONE",\n    bound=Shape2D[Literal[ONE], Literal[ONE]],\n)\nSHAPE_2D_MUL_TO_TWO = TypeVar(\n    "SHAPE_2D_MUL_TO_TWO",\n    bound=Union[Shape2D[Literal[ONE], Literal[TWO]], Shape2D[Literal[TWO], Literal[ONE]]],\n)\nSHAPE_2D_MUL_TO_THREE = TypeVar(\n    "SHAPE_2D_MUL_TO_THREE",\n    bound=Union[Shape2D[Literal[ONE], Literal[THREE]], Shape2D[Literal[THREE], Literal[ONE]]],\n)\nSHAPE_2D_MUL_TO_FOUR = TypeVar(\n    "SHAPE_2D_MUL_TO_FOUR",\n    bound=Union[\n        Shape2D[Literal[ONE], Literal[FOUR]],\n        Shape2D[Literal[TWO], Literal[TWO]],\n        Shape2D[Literal[FOUR], Literal[ONE]],\n    ],\n)\n')),(0,p.kt)("p",null,"Then lastly we wire these types up into individual ",(0,p.kt)("inlineCode",{parentName:"p"},"ravel")," overloads (and\ncover a few generic ones while we're at it):"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-python"},"@overload\ndef ravel(arr: NDArray[SHAPE_2D_MUL_TO_ONE, GenericDType]) -> NDArray[Shape1D[ONE], GenericDType]:\n    ...\n\n\n@overload\ndef ravel(arr: NDArray[SHAPE_2D_MUL_TO_TWO, GenericDType]) -> NDArray[Shape1D[TWO], GenericDType]:\n    ...\n\n\n@overload\ndef ravel(arr: NDArray[SHAPE_2D_MUL_TO_THREE, GenericDType]) -> NDArray[Shape1D[THREE], GenericDType]:\n    ...\n\n\n@overload\ndef ravel(arr: NDArray[SHAPE_2D_MUL_TO_FOUR, GenericDType]) -> NDArray[Shape1D[FOUR], GenericDType]:\n    ...\n\n@overload\ndef ravel(arr: NDArray[Shape2D[T1, ONE], GenericDType]) -> NDArray[Shape1D[T1], GenericDType]:\n    ...\n\n\n@overload\ndef ravel(arr: NDArray[Shape2D[ONE, T1], GenericDType]) -> NDArray[Shape1D[T1], GenericDType]:\n    ...\n\n\n@overload\ndef ravel(arr: NDArray[Shape1D[T1], GenericDType]) -> NDArray[Shape1D[T1], GenericDType]:\n    ...\n")),(0,p.kt)("p",null,"Now we can rinse and repeat for as many numbers as we like!"),(0,p.kt)("p",null,"Here is how we'd use this typing to catch a shape type error with ",(0,p.kt)("inlineCode",{parentName:"p"},"ravel"),":"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-python"},"import numpy as np\nfrom numpy.typing import NDArray\n\nfrom numpy_shape_typing.rand import rand_normal_matrix\nfrom numpy_shape_typing.ravel import ravel\nfrom numpy_shape_typing.types import FOUR, SEVEN, TWO, Shape1D, Shape2D\n\nA: NDArray[Shape2D[TWO, FOUR], np.float64] = rand_normal_matrix((2, 4))\nB: NDArray[Shape1D[SEVEN], np.float64] = ravel(A)\nprint(B)\n")),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-bash"},"py -m pyright raveling.py --lib\n")),(0,p.kt)("h2",{id:"putting-it-all-together"},"Putting it all together"),(0,p.kt)("p",null,"So far we've gone through typing a small subset of ",(0,p.kt)("inlineCode",{parentName:"p"},"numpy"),"'s functions\n(",(0,p.kt)("inlineCode",{parentName:"p"},"np.random.standard_normal"),", ",(0,p.kt)("inlineCode",{parentName:"p"},"np.dot"),", ",(0,p.kt)("inlineCode",{parentName:"p"},"np.add"),", and ",(0,p.kt)("inlineCode",{parentName:"p"},"np.ravel")," in all)."),(0,p.kt)("p",null,"Now we can chain these typed functions together to form a typed ",(0,p.kt)("inlineCode",{parentName:"p"},"Linear"),"\nimplementation like so:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-python"},'from typing import Literal\n\nimport numpy as np\nfrom numpy.typing import NDArray\n\nfrom numpy_shape_typing.add import add\nfrom numpy_shape_typing.dot import dot\nfrom numpy_shape_typing.rand import rand_normal_matrix\nfrom numpy_shape_typing.ravel import ravel\nfrom numpy_shape_typing.types import ONE, T1, T2, GenericDType, Shape1D, Shape2D\n\n\ndef Linear(\n        A: NDArray[Shape2D[T1, T2], GenericDType],\n        x: NDArray[Shape2D[T2, ONE], GenericDType],\n        b: NDArray[Shape2D[T1, ONE], GenericDType],\n) -> NDArray[Shape1D[T1], GenericDType]:\n    Ax = dot(A, x)\n    Axb = add(Ax, b)\n    return ravel(Axb)\n\n\nIN_DIM = Literal[3]\nin_dim: IN_DIM = 3\n\nOUT_DIM = Literal[4]\nout_dim: OUT_DIM = 4\n\n# bad type >:(\nBAD_OUT_DIM = Literal[5]\n\nA: NDArray[Shape2D[OUT_DIM, IN_DIM], np.float64] = rand_normal_matrix((out_dim, in_dim))\nx: NDArray[Shape2D[IN_DIM, ONE], np.float64] = rand_normal_matrix((in_dim, 1))\nb: NDArray[Shape2D[OUT_DIM, ONE], np.float64] = rand_normal_matrix((out_dim, 1))\n\n# this is a bad type! we should have an output shape type of "Shape1D[BAD_OUT_DIM]"\ny: NDArray[Shape1D[BAD_OUT_DIM], np.float64] = Linear(A, x, b)\n')),(0,p.kt)("p",null,"I've included an intentional type error which should be caught by ",(0,p.kt)("inlineCode",{parentName:"p"},"pyright"),"\nlike so:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-bash"},"py -m pyright linear_type_bad.py --lib\n")),(0,p.kt)("p",null,"And huzzah again! ",(0,p.kt)("inlineCode",{parentName:"p"},"pyright")," has caught the shape type error!"),(0,p.kt)("p",null,"And now we can fix this shape error by changing ",(0,p.kt)("inlineCode",{parentName:"p"},"BAD_OUT_DIM")," to the correct\noutput dimension size."),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-python"},"from typing import Literal\n\nimport numpy as np\nfrom numpy.typing import NDArray\n\nfrom numpy_shape_typing.add import add\nfrom numpy_shape_typing.dot import dot\nfrom numpy_shape_typing.rand import rand_normal_matrix\nfrom numpy_shape_typing.ravel import ravel\nfrom numpy_shape_typing.types import ONE, T1, T2, GenericDType, Shape1D, Shape2D\n\n\ndef Linear(\n        A: NDArray[Shape2D[T1, T2], GenericDType],\n        x: NDArray[Shape2D[T2, ONE], GenericDType],\n        b: NDArray[Shape2D[T1, ONE], GenericDType],\n) -> NDArray[Shape1D[T1], GenericDType]:\n    Ax = dot(A, x)\n    Axb = add(Ax, b)\n    return ravel(Axb)\n\n\nIN_DIM = Literal[3]\nin_dim: IN_DIM = 3\n\nOUT_DIM = Literal[4]\nout_dim: OUT_DIM = 4\n\nA: NDArray[Shape2D[OUT_DIM, IN_DIM], np.float64] = rand_normal_matrix((out_dim, in_dim))\nx: NDArray[Shape2D[IN_DIM, ONE], np.float64] = rand_normal_matrix((in_dim, 1))\nb: NDArray[Shape2D[OUT_DIM, ONE], np.float64] = rand_normal_matrix((out_dim, 1))\ny: NDArray[Shape1D[OUT_DIM], np.float64] = Linear(A, x, b)\n")),(0,p.kt)("p",null,"And if we check with ",(0,p.kt)("inlineCode",{parentName:"p"},"pyright"),"."),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-bash"},"py -m pyright linear_type_good.py --lib\n")),(0,p.kt)("p",null,(0,p.kt)("inlineCode",{parentName:"p"},"pyright")," tells us that our types are consistent!"))}m.isMDXComponent=!0}}]);
//# sourceMappingURL=component---content-posts-13-shape-typing-numpy-arrays-index-mdx-7bb20a60e83fb880fe2c.js.map