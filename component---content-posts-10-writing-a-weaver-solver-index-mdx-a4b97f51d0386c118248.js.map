{"version":3,"file":"component---content-posts-10-writing-a-weaver-solver-index-mdx-a4b97f51d0386c118248.js","mappings":"iRAQaA,EAAe,CAAC,EACvBC,EAAc,CAClBD,aAAAA,GAEIE,EAAYC,EAAAA,EACH,SAASC,EAAT,GAGX,IAFFC,EAEC,EAFDA,WACGC,GACF,YACD,OAAO,QAACJ,GAAD,UAAeD,EAAiBK,EAAhC,CAAuCD,WAAYA,EAAYE,QAAQ,eAG5E,2DAA6C,aAAGC,WAAW,IACvD,KAAQ,iCADiC,UAA7C,0LAKA,yDACA,cACE,GAAM,qCADR,uCAGA,8IAEA,6GAEA,iDAAmC,aAAGA,WAAW,IAC7C,KAAQ,yCADuB,4BAAnC,+CAIA,oBAAK,gBAAMA,WAAW,MAClB,UAAa,iBADZ,qMAML,oBAAK,gBAAMA,WAAW,MAClB,UAAa,iBADZ,4BAIL,qDAAuC,sBAAYA,WAAW,KAAvB,QAAvC,YACA,cACE,GAAM,oCADR,sCAGA,mKAEA,uKAEA,4KAEA,oBAAK,gBAAMA,WAAW,MAClB,UAAa,mBADZ,8xBAqBL,qIAEA,4EACA,kBAAG,gBAAMA,WAAW,IAChB,UAAa,4BACb,MAAS,CACP,SAAY,WACZ,QAAW,QACX,WAAc,OACd,YAAe,OACf,SAAY,WAPf,YAUC,gBAAMA,WAAW,OACf,UAAa,qCACb,MAAS,CACP,cAAiB,qBACjB,SAAY,WACZ,OAAU,IACV,KAAQ,IACR,gBAAmB,gkBACnB,eAAkB,QAClB,QAAW,WAnBhB,QAsBH,mBAASA,WAAW,QAApB,gBACQ,kBAAQA,WAAW,UACnB,OAAU,CAAC,yEAA0E,0EACrF,MAAS,oCACT,KAAQ,eAJhB,gBAMQ,kBAAQA,WAAW,UACnB,OAAU,CAAC,wEAAyE,yEACpF,MAAS,oCACT,KAAQ,cAThB,gBAWQ,eAAKA,WAAW,UAChB,UAAa,0BACb,IAAO,kEACP,IAAO,MACP,MAAS,qCACT,QAAW,OACX,SAAY,QACZ,MAAS,CACP,MAAS,OACT,OAAU,OACV,OAAU,IACV,cAAiB,SACjB,SAAY,WACZ,IAAO,IACP,KAAQ,OAzBlB,cAtBG,YAoDH,4HAEA,gEACuC,aAAGC,KAAK,0BAAR,0BADvC,QAEE,aAAGA,KAAK,yBAAR,wBAFF,MAIA,cACE,GAAM,qCADR,wCAGA,mJAEA,qHAEA,oBAAK,gBAAMD,WAAW,MAClB,UAAa,mBADZ,0vDAyDL,oBAAK,gBAAMA,WAAW,MAClB,UAAa,iBADZ,gDAIL,0DACA,kDAGH,CAEDJ,EAAWM,gBAAiB,C","sources":["webpack://TAOA/./content/posts/10_writing_a_weaver_solver/index.mdx"],"sourcesContent":["import * as React from 'react'\n  /* @jsx mdx */\nimport { mdx } from '@mdx-js/react';\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\n\nimport DefaultLayout from \"/home/node/work/src/templates/post.template.tsx\";\nexport const _frontmatter = {};\nconst layoutProps = {\n  _frontmatter\n};\nconst MDXLayout = DefaultLayout;\nexport default function MDXContent({\n  components,\n  ...props\n}) {\n  return <MDXLayout {...layoutProps} {...props} components={components} mdxType=\"MDXLayout\">\n\n\n    <p>{`Almost every night my wife and I play `}<a parentName=\"p\" {...{\n        \"href\": \"https://wordwormdormdork.com/\"\n      }}>{`Weaver`}</a>{` together. It's always fun after\nseveral nights not finding the shortest \"optimal\" sequence of words it got me\nthinking. \"How hard could it be to write an optimal Weaver solver?\"`}</p>\n    <p>{`So I made one. Here's how I did it.`}</p>\n    <h2 {...{\n      \"id\": \"step-1-getting-the-weaver-lexicon\"\n    }}>{`Step 1: Getting the Weaver lexicon`}</h2>\n    <p>{`Weaver is based around finding a sequence of 4 letter words that each differ\nby one letter and lead to some final word.`}</p>\n    <p>{`The obvious first step to making a Weaver solver is to get all English 4\nletter words!`}</p>\n    <p>{`I started by downloading an `}<a parentName=\"p\" {...{\n        \"href\": \"https://github.com/dwyl/english-words\"\n      }}>{`English dictionary on GH`}</a>{` and filtered out all non\n4 letter words.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-bash\"\n      }}>{`wget https://github.com/dwyl/english-words/raw/master/words_alpha.txt -O /tmp/words.txt\nawk '{ if (length($0) == 5 ) print }' /tmp/words.txt | uniq > /tmp/4words.txt\nwc -l /tmp/4words.txt\n`}</code></pre>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-text\"\n      }}>{`7186 /tmp/4words.txt\n`}</code></pre>\n    <p>{`We see here that our lexicon is `}<inlineCode parentName=\"p\">{`7186`}</inlineCode>{` words.`}</p>\n    <h2 {...{\n      \"id\": \"step-2-building-the-weaver-graph\"\n    }}>{`Step 2: Building the Weaver graph`}</h2>\n    <p>{`The next step is to build a representation of the Weaver \"solution space\" that\nwe can work with to enable us to find the shortest word path.`}</p>\n    <p>{`The simplest representation I could think of is a graph where the nodes are\nthe words, and the edges link words that have a 1 letter difference.`}</p>\n    <p>{`This representation is convenient because once we make it, we can run a\nshortest path graph algorithm (like Djikstra's) to get the optimal word path.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-python\"\n      }}>{`def is_distance_one(word1, word2):\n    \"\"\"If the words share 3 letters, they are distsance one\"\"\"\n    word1 = set((i, w) for i, w in enumerate(word1))\n    word2 = set((i, w) for i, w in enumerate(word2))\n    return len(set(word1).intersection(set(word2))) == 3\n\nweaver_graph = {}\nwith open('/tmp/4words.txt', 'r') as four_words:\n    for new_word in map(lambda w:w.strip(),four_words):\n        weaver_graph[new_word] = []\n        for existing_word, possible_next_words in weaver_graph.items():\n            if is_distance_one(new_word, existing_word):\n                weaver_graph[new_word].append(existing_word)\n                weaver_graph[existing_word].append(new_word)\n\nimport json\nwith open(\"/tmp/weaver_graph.json\",\"w+\") as f:\n    f.write(json.dumps(weaver_graph))\n`}</code></pre>\n    <p>{`This is a naive algorithm to create the graph, but it's simple, to the point,\nand we only have to run it once.`}</p>\n    <p>{`Now that the graph is built, let's try visualizing it!`}</p>\n    <p><span parentName=\"p\" {...{\n        \"className\": \"gatsby-resp-image-wrapper\",\n        \"style\": {\n          \"position\": \"relative\",\n          \"display\": \"block\",\n          \"marginLeft\": \"auto\",\n          \"marginRight\": \"auto\",\n          \"maxWidth\": \"2657px\"\n        }\n      }}>{`\n      `}<span parentName=\"span\" {...{\n          \"className\": \"gatsby-resp-image-background-image\",\n          \"style\": {\n            \"paddingBottom\": \"53.56000000000001%\",\n            \"position\": \"relative\",\n            \"bottom\": \"0\",\n            \"left\": \"0\",\n            \"backgroundImage\": \"url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAIAAADwazoUAAAACXBIWXMAAA7EAAAOxAGVKw4bAAABSElEQVQoz12Sa4uCUBCG/f//qA9GCIGUpFhQBKvmhexitd28tLr77Bk5RC90GKZ5zsw7R6PrurZtf5Qk/hD51+vFqTOU/SoZZMuy/FZ6Pp91XTdNI9UfIvkJU52m6XK5nM/n4/E4SRLugteABGSqquIv6kkKb9zv9yiKVqvVZDIZjUa+72dZdrvd9AgiYjLAj8eDW8SjcTwe1+s1sOu6s9kMeLFYxHG82+0wIiOIc4FrJRneoM5xHNM0B4PBcDj0PC8IAkj6bzYbRpBpWYfYESOdknE+n8MwtG0b3rIsnLMCeoLt93sCfF0uF8oI9Np7mMuKoqA/PafTKTBtISmlJyf84XDQLjT5D/OjiDVQwaq/lJiFXUCSp2ee57i4Xq/6qfpty4ch8+DqdDptt1smhxG30pk88fsj97D+vETyqvJJcJZK78+r9Qc75m96Rn1ZwQAAAABJRU5ErkJggg==')\",\n            \"backgroundSize\": \"cover\",\n            \"display\": \"block\"\n          }\n        }}></span>{`\n  `}<picture parentName=\"span\">{`\n          `}<source parentName=\"picture\" {...{\n            \"srcSet\": [\"/static/1dd2f625b877cb752e899f5cedac963a/a3bc4/weaver_graph.webp 2500w\", \"/static/1dd2f625b877cb752e899f5cedac963a/e63b7/weaver_graph.webp 2657w\"],\n            \"sizes\": \"(max-width: 2657px) 100vw, 2657px\",\n            \"type\": \"image/webp\"\n          }}></source>{`\n          `}<source parentName=\"picture\" {...{\n            \"srcSet\": [\"/static/1dd2f625b877cb752e899f5cedac963a/412e4/weaver_graph.png 2500w\", \"/static/1dd2f625b877cb752e899f5cedac963a/370f5/weaver_graph.png 2657w\"],\n            \"sizes\": \"(max-width: 2657px) 100vw, 2657px\",\n            \"type\": \"image/png\"\n          }}></source>{`\n          `}<img parentName=\"picture\" {...{\n            \"className\": \"gatsby-resp-image-image\",\n            \"src\": \"/static/1dd2f625b877cb752e899f5cedac963a/370f5/weaver_graph.png\",\n            \"alt\": \"img\",\n            \"title\": \"Full view of the Weaver word graph\",\n            \"loading\": \"lazy\",\n            \"decoding\": \"async\",\n            \"style\": {\n              \"width\": \"100%\",\n              \"height\": \"100%\",\n              \"margin\": \"0\",\n              \"verticalAlign\": \"middle\",\n              \"position\": \"absolute\",\n              \"top\": \"0\",\n              \"left\": \"0\"\n            }\n          }}></img>{`\n        `}</picture>{`\n    `}</span></p>\n    <p>{`This picture doesn't tell us much besides dense vs. not dense, but it's a\npretty picture nonetheless!`}</p>\n    <p>\nIf you want explore the graph for yourself,<a href=\"/img/weaver_graph.json\"> here is the JSON blob</a> and\n      <a href=\"/img/weaver_graph.svg\"> here is the SVG viz</a>.\n    </p>\n    <h2 {...{\n      \"id\": \"step-3-building-the-weaver-solver\"\n    }}>{`Step 3: Building the Weaver solver!`}</h2>\n    <p>{`Now that we have a graph of all the Weaver words and the transitions between\nthem, all we have left to do is build a solver!`}</p>\n    <p>{`As mentioned we can now use a Djikstra's shortest path algorithm to find our\noptimal solution!`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-python\"\n      }}>{`import json\nimport heapq\nfrom collections import namedtuple\nfrom dataclasses import dataclass\n\n@dataclass\nclass QueueItem:\n    node: str\n    path: list[str]\n    cost: int = 1\n\n    def __lt__(self, other):\n        return self.cost < other.cost\n\nclass WeaverSolver:\n    def __init__(self, weaver_graph_path: str):\n        self.weaver_graph = json.loads(open(weaver_graph_path,\"r\").read())\n\n    def solve(self, start_word: str, end_word: str, avoid_words: list[str] = None) -> list[str]:\n        assert start_word in self.weaver_graph, f\"Start word {start_word} not in graph\"\n        assert end_word in self.weaver_graph, f\"End word {end_word} not in graph\"\n\n        if not avoid_words:\n            avoid_words = []\n\n        init_queue_item = QueueItem(node=start_word, path=[], cost=0)\n        queue = [init_queue_item]\n        seen = set()\n\n        while True:\n            qi = heapq.heappop(queue)\n            if qi.node not in seen:\n\n                qi.path = qi.path + [qi.node]\n                seen.add(qi.node)\n\n                # if we are at the end, return the path\n                if qi.node == end_word:\n                    return qi.path\n\n                # search edges avoiding nodes and increasing cost\n                for search_node in self.weaver_graph[qi.node]:\n                    cost = float(\"inf\") if search_node in avoid_words else qi.cost + 1\n                    heapq.heappush(\n                        queue,\n                        QueueItem(\n                            node=search_node,\n                            path=qi.path,\n                            cost=cost,\n                        )\n                    )\n\nsolver = WeaverSolver(\"/tmp/weaver_graph.json\")\nprint(solver.solve(\"bone\", \"cast\"))\n`}</code></pre>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-text\"\n      }}>{`['bone', 'bane', 'cane', 'cant', 'cast']\n`}</code></pre>\n    <p>{`And huzzah! We have a Weaver solver!`}</p>\n    <p>{`Thanks for reading! ヾ(⌐■_■)ノ♪`}</p>\n\n    </MDXLayout>;\n}\n;\nMDXContent.isMDXComponent = true;\n      "],"names":["_frontmatter","layoutProps","MDXLayout","DefaultLayout","MDXContent","components","props","mdxType","parentName","href","isMDXComponent"],"sourceRoot":""}